{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Welcome to GraphRAG", "text": "<p>\ud83d\udc49 Microsoft Research Blog Post  \ud83d\udc49 GraphRAG Arxiv</p> <p> </p> <p> Figure 1: An LLM-generated knowledge graph built using GPT-4 Turbo. </p> <p>GraphRAG is a structured, hierarchical approach to Retrieval Augmented Generation (RAG), as opposed to naive semantic-search approaches using plain text snippets. The GraphRAG process involves extracting a knowledge graph out of raw text, building a community hierarchy, generating summaries for these communities, and then leveraging these structures when perform RAG-based tasks.</p> <p>To learn more about GraphRAG and how it can be used to enhance your language model's ability to reason about your private data, please visit the Microsoft Research Blog Post.</p>"}, {"location": "#get-started-with-graphrag", "title": "Get Started with GraphRAG \ud83d\ude80", "text": "<p>To start using GraphRAG, check out the Get Started guide. For a deeper dive into the main sub-systems, please visit the docpages for the Indexer and Query packages.</p>"}, {"location": "#graphrag-vs-baseline-rag", "title": "GraphRAG vs Baseline RAG \ud83d\udd0d", "text": "<p>Retrieval-Augmented Generation (RAG) is a technique to improve LLM outputs using real-world information. This technique is an important part of most LLM-based tools and the majority of RAG approaches use vector similarity as the search technique, which we call Baseline RAG. GraphRAG uses knowledge graphs to provide substantial improvements in question-and-answer performance when reasoning about complex information. RAG techniques have shown promise in helping LLMs to reason about private datasets - data that the LLM is not trained on and has never seen before, such as an enterprise\u2019s proprietary research, business documents, or communications. Baseline RAG was created to help solve this problem, but we observe situations where baseline RAG performs very poorly. For example:</p> <ul> <li>Baseline RAG struggles to connect the dots. This happens when answering a question requires traversing disparate pieces of information through their shared attributes in order to provide new synthesized insights.</li> <li>Baseline RAG performs poorly when being asked to holistically understand summarized semantic concepts over large data collections or even singular large documents.</li> </ul> <p>To address this, the tech community is working to develop methods that extend and enhance RAG. Microsoft Research\u2019s new approach, GraphRAG, creates a knowledge graph based on an input corpus. This graph, along with community summaries and graph machine learning outputs, are used to augment prompts at query time. GraphRAG shows substantial improvement in answering the two classes of questions described above, demonstrating intelligence or mastery that outperforms other approaches previously applied to private datasets.</p>"}, {"location": "#the-graphrag-process", "title": "The GraphRAG Process \ud83e\udd16", "text": "<p>GraphRAG builds upon our prior research and tooling using graph machine learning. The basic steps of the GraphRAG process are as follows:</p>"}, {"location": "#index", "title": "Index", "text": "<ul> <li>Slice up an input corpus into a series of TextUnits, which act as analyzable units for the rest of the process, and provide fine-grained references in our outputs.</li> <li>Extract all entities, relationships, and key claims from the TextUnits.</li> <li>Perform a hierarchical clustering of the graph using the Leiden technique. To see this visually, check out Figure 1 above. Each circle is an entity (e.g., a person, place, or organization), with the size representing the degree of the entity, and the color representing its community.</li> <li>Generate summaries of each community and its constituents from the bottom-up. This aids in holistic understanding of the dataset.</li> </ul>"}, {"location": "#query", "title": "Query", "text": "<p>At query time, these structures are used to provide materials for the LLM context window when answering a question. The primary query modes are:</p> <ul> <li>Global Search for reasoning about holistic questions about the corpus by leveraging the community summaries.</li> <li>Local Search for reasoning about specific entities by fanning-out to their neighbors and associated concepts.</li> <li>DRIFT Search for reasoning about specific entities by fanning-out to their neighbors and associated concepts, but with the added context of community information.</li> <li>Basic Search for those times when your query is best answered by baseline RAG (standard top k vector search).</li> </ul>"}, {"location": "#prompt-tuning", "title": "Prompt Tuning", "text": "<p>Using GraphRAG with your data out of the box may not yield the best possible results. We strongly recommend to fine-tune your prompts following the Prompt Tuning Guide in our documentation.</p>"}, {"location": "#versioning", "title": "Versioning", "text": "<p>Please see the breaking changes document for notes on our approach to versioning the project.</p> <p>Always run <code>graphrag init --root [path] --force</code> between minor version bumps to ensure you have the latest config format. Run the provided migration notebook between major version bumps if you want to avoid re-indexing prior datasets. Note that this will overwrite your configuration and prompts, so backup if necessary.</p>"}, {"location": "blog_posts/", "title": "Microsoft Research Blog", "text": "<ul> <li> <p> GraphRAG: Unlocking LLM discovery on narrative private data</p> <p>Published February 13, 2024 <p>By Jonathan Larson, Senior Principal Data Architect; Steven Truitt, Principal Program Manager</p> <li> <p> GraphRAG: New tool for complex data discovery now on GitHub</p> <p>Published July 2, 2024 <p>By Darren Edge, Senior Director; Ha Trinh, Senior Data Scientist; Steven Truitt, Principal Program Manager; Jonathan Larson, Senior Principal Data Architect</p> <li> <p> GraphRAG auto-tuning provides rapid adaptation to new domains</p> <p>Published September 9, 2024 <p>By Alonso Guevara Fern\u00e1ndez, Sr. Software Engineer; Katy Smith, Data Scientist II; Joshua Bradley, Senior Data Scientist; Darren Edge, Senior Director; Ha Trinh, Senior Data Scientist; Sarah Smith, Senior Program Manager; Ben Cutler, Senior Director; Steven Truitt, Principal Program Manager; Jonathan Larson, Senior Principal Data Architect</p> <li> <p> Introducing DRIFT Search: Combining global and local search methods to improve quality and efficiency</p> <p>Published October 31, 2024 <p>By Julian Whiting, Senior Machine Learning Engineer; Zachary Hills , Senior Software Engineer; Alonso Guevara Fern\u00e1ndez, Sr. Software Engineer; Ha Trinh, Senior Data Scientist; Adam Bradley , Managing Partner, Strategic Research; Jonathan Larson, Senior Principal Data Architect</p> <li> <p> GraphRAG: Improving global search via dynamic community selection</p> <p>Published November 15, 2024 <p>By Bryan Li, Research Intern; Ha Trinh, Senior Data Scientist; Darren Edge, Senior Director; Jonathan Larson, Senior Principal Data Architect</p> <li> <p> LazyGraphRAG: Setting a new standard for quality and cost</p> <p>Published November 25, 2024 <p>By Darren Edge, Senior Director; Ha Trinh, Senior Data Scientist;  Jonathan Larson, Senior Principal Data Architect</p> <li> <p> Moving to GraphRAG 1.0 \u2013 Streamlining ergonomics for developers and users</p> <p>Published December 16, 2024 <p>By Nathan Evans, Principal Software Architect; Alonso Guevara Fern\u00e1ndez, Senior Software Engineer; Joshua Bradley, Senior Data Scientist</p>"}, {"location": "cli/", "title": "CLI Reference", "text": "<p>This page documents the command-line interface of the graphrag library.</p>"}, {"location": "cli/#graphrag", "title": "graphrag", "text": "<p>GraphRAG: A graph-based retrieval-augmented generation (RAG) system.</p> <p>Usage:</p> <pre><code> [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --install-completion  Install completion for the current shell.\n  --show-completion     Show completion for the current shell, to copy it or\n                        customize the installation.\n</code></pre>"}, {"location": "cli/#index", "title": "index", "text": "<p>Build a knowledge graph index.</p> <p>Usage:</p> <pre><code> index [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -c, --config PATH               The configuration to use.\n  -r, --root PATH                 The project root directory.  \\[default: .]\n  -m, --method [standard|fast|standard-update|fast-update]\n                                  The indexing method to use.  \\[default:\n                                  standard]\n  -v, --verbose                   Run the indexing pipeline with verbose\n                                  logging\n  --memprofile                    Run the indexing pipeline with memory\n                                  profiling\n  --dry-run                       Run the indexing pipeline without executing\n                                  any steps to inspect and validate the\n                                  configuration.\n  --cache / --no-cache            Use LLM cache.  \\[default: cache]\n  --skip-validation               Skip any preflight validation. Useful when\n                                  running no LLM steps.\n  -o, --output PATH               Indexing pipeline output directory.\n                                  Overrides output.base_dir in the\n                                  configuration file.\n</code></pre>"}, {"location": "cli/#init", "title": "init", "text": "<p>Generate a default configuration file.</p> <p>Usage:</p> <pre><code> init [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -r, --root PATH  The project root directory.  \\[default: .]\n  -f, --force      Force initialization even if the project already exists.\n</code></pre>"}, {"location": "cli/#prompt-tune", "title": "prompt-tune", "text": "<p>Generate custom graphrag prompts with your own data (i.e. auto templating).</p> <p>Usage:</p> <pre><code> prompt-tune [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -r, --root PATH                 The project root directory.  \\[default: .]\n  -c, --config PATH               The configuration to use.\n  -v, --verbose                   Run the prompt tuning pipeline with verbose\n                                  logging.\n  --domain TEXT                   The domain your input data is related to.\n                                  For example 'space science', 'microbiology',\n                                  'environmental news'. If not defined, a\n                                  domain will be inferred from the input data.\n  --selection-method [all|random|top|auto]\n                                  The text chunk selection method.  \\[default:\n                                  random]\n  --n-subset-max INTEGER          The number of text chunks to embed when\n                                  --selection-method=auto.  \\[default: 300]\n  --k INTEGER                     The maximum number of documents to select\n                                  from each centroid when --selection-\n                                  method=auto.  \\[default: 15]\n  --limit INTEGER                 The number of documents to load when\n                                  --selection-method={random,top}.  \\[default:\n                                  15]\n  --max-tokens INTEGER            The max token count for prompt generation.\n                                  \\[default: 2000]\n  --min-examples-required INTEGER\n                                  The minimum number of examples to\n                                  generate/include in the entity extraction\n                                  prompt.  \\[default: 2]\n  --chunk-size INTEGER            The size of each example text chunk.\n                                  Overrides chunks.size in the configuration\n                                  file.  \\[default: 1200]\n  --overlap INTEGER               The overlap size for chunking documents.\n                                  Overrides chunks.overlap in the\n                                  configuration file.  \\[default: 100]\n  --language TEXT                 The primary language used for inputs and\n                                  outputs in graphrag prompts.\n  --discover-entity-types / --no-discover-entity-types\n                                  Discover and extract unspecified entity\n                                  types.  \\[default: discover-entity-types]\n  -o, --output PATH               The directory to save prompts to, relative\n                                  to the project root directory.  \\[default:\n                                  prompts]\n</code></pre>"}, {"location": "cli/#query", "title": "query", "text": "<p>Query a knowledge graph index.</p> <p>Usage:</p> <pre><code> query [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -m, --method [local|global|drift|basic]\n                                  The query algorithm to use.  \\[required]\n  -q, --query TEXT                The query to execute.  \\[required]\n  -c, --config PATH               The configuration to use.\n  -v, --verbose                   Run the query with verbose logging.\n  -d, --data PATH                 Index output directory (contains the parquet\n                                  files).\n  -r, --root PATH                 The project root directory.  \\[default: .]\n  --community-level INTEGER       Leiden hierarchy level from which to load\n                                  community reports. Higher values represent\n                                  smaller communities.  \\[default: 2]\n  --dynamic-community-selection / --no-dynamic-selection\n                                  Use global search with dynamic community\n                                  selection.  \\[default: no-dynamic-selection]\n  --response-type TEXT            Free-form description of the desired\n                                  response format (e.g. 'Single Sentence',\n                                  'List of 3-7 Points', etc.).  \\[default:\n                                  Multiple Paragraphs]\n  --streaming / --no-streaming    Print the response in a streaming manner.\n                                  \\[default: no-streaming]\n</code></pre>"}, {"location": "cli/#update", "title": "update", "text": "<p>Update an existing knowledge graph index.</p> <p>Applies a default output configuration (if not provided by config), saving the new index to the local file system in the <code>update_output</code> folder.</p> <p>Usage:</p> <pre><code> update [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -c, --config PATH               The configuration to use.\n  -r, --root PATH                 The project root directory.  \\[default: .]\n  -m, --method [standard|fast|standard-update|fast-update]\n                                  The indexing method to use.  \\[default:\n                                  standard]\n  -v, --verbose                   Run the indexing pipeline with verbose\n                                  logging.\n  --memprofile                    Run the indexing pipeline with memory\n                                  profiling.\n  --cache / --no-cache            Use LLM cache.  \\[default: cache]\n  --skip-validation               Skip any preflight validation. Useful when\n                                  running no LLM steps.\n  -o, --output PATH               Indexing pipeline output directory.\n                                  Overrides output.base_dir in the\n                                  configuration file.\n</code></pre>"}, {"location": "developing/", "title": "Development Guide", "text": ""}, {"location": "developing/#requirements", "title": "Requirements", "text": "Name Installation Purpose Python 3.10-3.12 Download The library is Python-based. uv Instructions uv is used for package management and virtualenv management in Python codebases"}, {"location": "developing/#getting-started", "title": "Getting Started", "text": ""}, {"location": "developing/#install-dependencies", "title": "Install Dependencies", "text": "<pre><code># (optional) create virtual environment\nuv venv --python 3.10\nsource .venv/bin/activate\n\n# install python dependencies\nuv sync --extra dev\n</code></pre>"}, {"location": "developing/#execute-the-indexing-engine", "title": "Execute the Indexing Engine", "text": "<pre><code>uv run poe index &lt;...args&gt;\n</code></pre>"}, {"location": "developing/#executing-queries", "title": "Executing Queries", "text": "<pre><code>uv run poe query &lt;...args&gt;\n</code></pre>"}, {"location": "developing/#azurite", "title": "Azurite", "text": "<p>Some unit and smoke tests use Azurite to emulate Azure resources. This can be started by running:</p> <pre><code>./scripts/start-azurite.sh\n</code></pre> <p>or by simply running <code>azurite</code> in the terminal if already installed globally. See the Azurite documentation for more information about how to install and use Azurite.</p>"}, {"location": "developing/#lifecycle-scripts", "title": "Lifecycle Scripts", "text": "<p>Our Python package utilize uv to manage dependencies and poethepoet to manage build scripts.</p> <p>Available scripts are:</p> <ul> <li><code>uv run poe index</code> - Run the Indexing CLI</li> <li><code>uv run poe query</code> - Run the Query CLI</li> <li><code>uv build</code> - This will build a wheel file and other distributable artifacts.</li> <li><code>uv run poe test</code> - This will execute all tests.</li> <li><code>uv run poe test_unit</code> - This will execute unit tests.</li> <li><code>uv run poe test_integration</code> - This will execute integration tests.</li> <li><code>uv run poe test_smoke</code> - This will execute smoke tests.</li> <li><code>uv run poe test_verbs</code> - This will execute tests of the basic workflows.</li> <li><code>uv run poe check</code> - This will perform a suite of static checks across the package, including:</li> <li>formatting</li> <li>documentation formatting</li> <li>linting</li> <li>security patterns</li> <li>type-checking</li> <li><code>uv run poe fix</code> - This will apply any available auto-fixes to the package. Usually this is just formatting fixes.</li> <li><code>uv run poe fix_unsafe</code> - This will apply any available auto-fixes to the package, including those that may be unsafe.</li> <li><code>uv run poe format</code> - Explicitly run the formatter across the package.</li> </ul>"}, {"location": "developing/#troubleshooting", "title": "Troubleshooting", "text": ""}, {"location": "developing/#runtimeerror-llvm-config-failed-executing-please-point-llvm_config-to-the-path-for-llvm-config-when-running-uv-install", "title": "\"RuntimeError: llvm-config failed executing, please point LLVM_CONFIG to the path for llvm-config\" when running uv install", "text": "<p>Make sure llvm-9 and llvm-9-dev are installed:</p> <p><code>sudo apt-get install llvm-9 llvm-9-dev</code></p> <p>and then in your bashrc, add</p> <p><code>export LLVM_CONFIG=/usr/bin/llvm-config-9</code></p>"}, {"location": "developing/#llm-call-constantly-exceeds-tpm-rpm-or-time-limits", "title": "LLM call constantly exceeds TPM, RPM or time limits", "text": "<p><code>GRAPHRAG_LLM_THREAD_COUNT</code> and <code>GRAPHRAG_EMBEDDING_THREAD_COUNT</code> are both set to 50 by default. You can modify these values to reduce concurrency. Please refer to the Configuration Documents</p>"}, {"location": "get_started/", "title": "Getting Started", "text": "<p>\u26a0\ufe0f GraphRAG can consume a lot of LLM resources! We strongly recommend starting with the tutorial dataset here until you understand how the system works, and consider experimenting with fast/inexpensive models first before committing to a big indexing job.</p>"}, {"location": "get_started/#requirements", "title": "Requirements", "text": "<p>Python 3.10-3.12</p> <p>To get started with the GraphRAG system, you have a few options:</p> <p>\ud83d\udc49 Install from pypi.  \ud83d\udc49 Use it from source</p> <p>The following is a simple end-to-end example for using the GraphRAG system, using the install from pypi option.</p> <p>It shows how to use the system to index some text, and then use the indexed data to answer questions about the documents.</p>"}, {"location": "get_started/#install-graphrag", "title": "Install GraphRAG", "text": "<pre><code>pip install graphrag\n</code></pre>"}, {"location": "get_started/#running-the-indexer", "title": "Running the Indexer", "text": "<p>We need to set up a data project and some initial configuration. First let's get a sample dataset ready:</p> <pre><code>mkdir -p ./christmas/input\n</code></pre> <p>Get a copy of A Christmas Carol by Charles Dickens from a trusted source:</p> <pre><code>curl https://www.gutenberg.org/cache/epub/24022/pg24022.txt -o ./christmas/input/book.txt\n</code></pre>"}, {"location": "get_started/#set-up-your-workspace-variables", "title": "Set Up Your Workspace Variables", "text": "<p>To initialize your workspace, first run the <code>graphrag init</code> command. Since we have already configured a directory named <code>./christmas</code> in the previous step, run the following command:</p> <pre><code>graphrag init --root ./christmas\n</code></pre> <p>This will create two files: <code>.env</code> and <code>settings.yaml</code> in the <code>./christmas</code> directory.</p> <ul> <li><code>.env</code> contains the environment variables required to run the GraphRAG pipeline. If you inspect the file, you'll see a single environment variable defined,   <code>GRAPHRAG_API_KEY=&lt;API_KEY&gt;</code>. Replace <code>&lt;API_KEY&gt;</code> with your own OpenAI or Azure API key.</li> <li><code>settings.yaml</code> contains the settings for the pipeline. You can modify this file to change the settings for the pipeline.   </li> </ul>"}, {"location": "get_started/#using-openai", "title": "Using OpenAI", "text": "<p>If running in OpenAI mode, you only need to update the value of <code>GRAPHRAG_API_KEY</code> in the <code>.env</code> file with your OpenAI API key.</p>"}, {"location": "get_started/#using-azure-openai", "title": "Using Azure OpenAI", "text": "<p>In addition to setting your API key, Azure OpenAI users should set the variables below in the settings.yaml file. To find the appropriate sections, just search for the <code>models:</code> root configuration; you should see two sections, one for the default chat endpoint and one for the default embeddings endpoint. Here is an example of what to add to the chat model config:</p> <pre><code>type: azure_openai_chat # Or azure_openai_embedding for embeddings\napi_base: https://&lt;instance&gt;.openai.azure.com\napi_version: 2024-02-15-preview # You can customize this for other versions\ndeployment_name: &lt;azure_model_deployment_name&gt;\n</code></pre>"}, {"location": "get_started/#using-managed-auth-on-azure", "title": "Using Managed Auth on Azure", "text": "<p>To use managed auth, edit the auth_type in your model config and remove the api_key line:</p> <pre><code>auth_type: azure_managed_identity # Default auth_type is is api_key\n</code></pre> <p>You will also need to login with az login and select the subscription with your endpoint.</p>"}, {"location": "get_started/#running-the-indexing-pipeline", "title": "Running the Indexing pipeline", "text": "<p>Finally we'll run the pipeline!</p> <pre><code>graphrag index --root ./christmas\n</code></pre> <p></p> <p>This process will take some time to run. This depends on the size of your input data, what model you're using, and the text chunk size being used (these can be configured in your <code>settings.yaml</code> file). Once the pipeline is complete, you should see a new folder called <code>./christmas/output</code> with a series of parquet files.</p>"}, {"location": "get_started/#using-the-query-engine", "title": "Using the Query Engine", "text": "<p>Now let's ask some questions using this dataset.</p> <p>Here is an example using Global search to ask a high-level question:</p> <pre><code>graphrag query \\\n--root ./christmas \\\n--method global \\\n--query \"What are the top themes in this story?\"\n</code></pre> <p>Here is an example using Local search to ask a more specific question about a particular character:</p> <pre><code>graphrag query \\\n--root ./christmas \\\n--method local \\\n--query \"Who is Scrooge and what are his main relationships?\"\n</code></pre> <p>Please refer to Query Engine docs for detailed information about how to leverage our Local and Global search mechanisms for extracting meaningful insights from data after the Indexer has wrapped up execution.</p>"}, {"location": "get_started/#going-deeper", "title": "Going Deeper", "text": "<ul> <li>For more details about configuring GraphRAG, see the configuration documentation.</li> <li>To learn more about Initialization, refer to the Initialization documentation.</li> <li>For more details about using the CLI, refer to the CLI documentation.</li> <li>Check out our visualization guide for a more interactive experience in debugging and exploring the knowledge graph.</li> </ul>"}, {"location": "visualization_guide/", "title": "Visualizing and Debugging Your Knowledge Graph", "text": "<p>The following step-by-step guide walks through the process to visualize a knowledge graph after it's been constructed by graphrag. Note that some of the settings recommended below are based on our own experience of what works well. Feel free to change and explore other settings for a better visualization experience!</p>"}, {"location": "visualization_guide/#1-run-the-pipeline", "title": "1. Run the Pipeline", "text": "<p>Before building an index, please review your <code>settings.yaml</code> configuration file and ensure that graphml snapshots is enabled. <pre><code>snapshots:\n  graphml: true\n</code></pre> (Optional) To support other visualization tools and exploration, additional parameters can be enabled that provide access to vector embeddings. <pre><code>embed_graph:\n  enabled: true # will generate node2vec embeddings for nodes\numap:\n  enabled: true # will generate UMAP embeddings for nodes, giving the entities table an x/y position to plot\n</code></pre> After running the indexing pipeline over your data, there will be an output folder (defined by the <code>storage.base_dir</code> setting).</p> <ul> <li>Output Folder: Contains artifacts from the LLM\u2019s indexing pass.</li> </ul>"}, {"location": "visualization_guide/#2-locate-the-knowledge-graph", "title": "2. Locate the Knowledge Graph", "text": "<p>In the output folder, look for a file named <code>graph.graphml</code>. graphml is a standard file format supported by many visualization tools. We recommend trying Gephi.</p>"}, {"location": "visualization_guide/#3-open-the-graph-in-gephi", "title": "3. Open the Graph in Gephi", "text": "<ol> <li>Install and open Gephi</li> <li>Navigate to the <code>output</code> folder containing the various parquet files.</li> <li>Import the <code>graph.graphml</code> file into Gephi. This will result in a fairly plain view of the undirected graph nodes and edges.</li> </ol>"}, {"location": "visualization_guide/#4-install-the-leiden-algorithm-plugin", "title": "4. Install the Leiden Algorithm Plugin", "text": "<ol> <li>Go to <code>Tools</code> -&gt; <code>Plugins</code>.</li> <li>Search for \"Leiden Algorithm\".</li> <li>Click <code>Install</code> and restart Gephi.</li> </ol>"}, {"location": "visualization_guide/#5-run-statistics", "title": "5. Run Statistics", "text": "<ol> <li>In the <code>Statistics</code> tab on the right, click <code>Run</code> for <code>Average Degree</code> and <code>Leiden Algorithm</code>.</li> </ol> <ol> <li>For the Leiden Algorithm, adjust the settings:</li> <li>Quality function: Modularity</li> <li>Resolution: 1</li> </ol>"}, {"location": "visualization_guide/#6-color-the-graph-by-clusters", "title": "6. Color the Graph by Clusters", "text": "<ol> <li>Go to the <code>Appearance</code> pane in the upper left side of Gephi.</li> </ol> <ol> <li>Select <code>Nodes</code>, then <code>Partition</code>, and click the color palette icon in the upper right.</li> <li>Choose <code>Cluster</code> from the dropdown.</li> <li>Click the <code>Palette...</code> hyperlink, then <code>Generate...</code>.</li> <li>Uncheck <code>Limit number of colors</code>, click <code>Generate</code>, and then <code>Ok</code>.</li> <li>Click <code>Apply</code> to color the graph. This will color the graph based on the partitions discovered by Leiden.</li> </ol>"}, {"location": "visualization_guide/#7-resize-nodes-by-degree-centrality", "title": "7. Resize Nodes by Degree Centrality", "text": "<ol> <li>In the <code>Appearance</code> pane in the upper left, select <code>Nodes</code> -&gt; <code>Ranking</code></li> <li>Select the <code>Sizing</code> icon in the upper right.</li> <li>Choose <code>Degree</code> and set:</li> <li>Min: 10</li> <li>Max: 150</li> <li>Click <code>Apply</code>.</li> </ol>"}, {"location": "visualization_guide/#8-layout-the-graph", "title": "8. Layout the Graph", "text": "<ol> <li>In the <code>Layout</code> tab in the lower left, select <code>OpenORD</code>.</li> </ol> <ol> <li>Set <code>Liquid</code> and <code>Expansion</code> stages to 50, and everything else to 0.</li> <li>Click <code>Run</code> and monitor the progress.</li> </ol>"}, {"location": "visualization_guide/#9-run-forceatlas2", "title": "9. Run ForceAtlas2", "text": "<ol> <li>Select <code>Force Atlas 2</code> in the layout options.</li> </ol> <ol> <li>Adjust the settings:</li> <li>Scaling: 15</li> <li>Dissuade Hubs: checked</li> <li>LinLog mode: uncheck</li> <li>Prevent Overlap: checked</li> <li>Click <code>Run</code> and wait.</li> <li>Press <code>Stop</code> when it looks like the graph nodes have settled and no longer change position significantly.</li> </ol>"}, {"location": "visualization_guide/#10-add-text-labels-optional", "title": "10. Add Text Labels (Optional)", "text": "<ol> <li>Turn on text labels in the appropriate section.</li> <li>Configure and resize them as needed.</li> </ol> <p>Your final graph should now be visually organized and ready for analysis!</p>"}, {"location": "config/init/", "title": "Configuring GraphRAG Indexing", "text": "<p>To start using GraphRAG, you must generate a configuration file. The <code>init</code> command is the easiest way to get started. It will create a <code>.env</code> and <code>settings.yaml</code> files in the specified directory with the necessary configuration settings. It will also output the default LLM prompts used by GraphRAG.</p>"}, {"location": "config/init/#usage", "title": "Usage", "text": "<pre><code>graphrag init [--root PATH] [--force, --no-force]\n</code></pre>"}, {"location": "config/init/#options", "title": "Options", "text": "<ul> <li><code>--root PATH</code> - The project root directory to initialize graphrag at. Default is the current directory.</li> <li><code>--force</code>, <code>--no-force</code> - Optional, default is --no-force. Overwrite existing configuration and prompt files if they exist.</li> </ul>"}, {"location": "config/init/#example", "title": "Example", "text": "<pre><code>graphrag init --root ./ragtest\n</code></pre>"}, {"location": "config/init/#output", "title": "Output", "text": "<p>The <code>init</code> command will create the following files in the specified directory:</p> <ul> <li><code>settings.yaml</code> - The configuration settings file. This file contains the configuration settings for GraphRAG.</li> <li><code>.env</code> - The environment variables file. These are referenced in the <code>settings.yaml</code> file.</li> <li><code>prompts/</code> - The LLM prompts folder. This contains the default prompts used by GraphRAG, you can modify them or run the Auto Prompt Tuning command to generate new prompts adapted to your data.</li> </ul>"}, {"location": "config/init/#next-steps", "title": "Next Steps", "text": "<p>After initializing your workspace, you can either run the Prompt Tuning command to adapt the prompts to your data or even start running the Indexing Pipeline to index your data. For more information on configuration options available, see the YAML details page.</p>"}, {"location": "config/models/", "title": "Language Model Selection and Overriding", "text": "<p>This page contains information on selecting a model to use and options to supply your own model for GraphRAG. Note that this is not a guide to finding the right model for your use case.</p>"}, {"location": "config/models/#default-model-support", "title": "Default Model Support", "text": "<p>GraphRAG was built and tested using OpenAI models, so this is the default model set we support. This is not intended to be a limiter or statement of quality or fitness for your use case, only that it's the set we are most familiar with for prompting, tuning, and debugging.</p> <p>GraphRAG also utilizes a language model wrapper library used by several projects within our team, called fnllm. fnllm provides two important functions for GraphRAG: rate limiting configuration to help us maximize throughput for large indexing jobs, and robust caching of API calls to minimize consumption on repeated indexes for testing, experimentation, or incremental ingest. fnllm uses the OpenAI Python SDK under the covers, so OpenAI-compliant endpoints are a base requirement out-of-the-box.</p> <p>Starting with version 2.6.0, GraphRAG supports using LiteLLM instead of fnllm for calling language models. LiteLLM provides support for 100+ models though it is important to note that when choosing a model it must support returning structured outputs adhering to a JSON schema. </p> <p>Example using LiteLLm as the language model tool for GraphRAG:</p> <pre><code>models:\n  default_chat_model:\n    type: chat\n    auth_type: api_key\n    api_key: ${GEMINI_API_KEY}\n    model_provider: gemini\n    model: gemini-2.5-flash-lite\n  default_embedding_model:\n    type: embedding\n    auth_type: api_key\n    api_key: ${GEMINI_API_KEY}\n    model_provider: gemini\n    model: gemini-embedding-001\n</code></pre> <p>To use LiteLLM one must </p> <ul> <li>Set <code>type</code> to either <code>chat</code> or <code>embedding</code>.</li> <li>Provide a <code>model_provider</code>, e.g., <code>openai</code>, <code>azure</code>, <code>gemini</code>, etc.</li> <li>Set the <code>model</code> to a one supported by the <code>model_provider</code>'s API.</li> <li>Provide a <code>deployment_name</code> if using <code>azure</code> as the <code>model_provider</code>.</li> </ul> <p>See Detailed Configuration for more details on configuration. View LiteLLm basic usage for details on how models are called (The <code>model_provider</code> is the portion prior to <code>/</code> while the <code>model</code> is the portion following the <code>/</code>).</p>"}, {"location": "config/models/#model-selection-considerations", "title": "Model Selection Considerations", "text": "<p>GraphRAG has been most thoroughly tested with the gpt-4 series of models from OpenAI, including gpt-4 gpt-4-turbo, gpt-4o, and gpt-4o-mini. Our arXiv paper, for example, performed quality evaluation using gpt-4-turbo. As stated above, non-OpenAI models are now supported with GraphRAG 2.6.0 and onwards through the use of LiteLLM but the suite of gpt-4 series of models from OpenAI remain the most tested and supported suite of models for GraphRAG.</p> <p>Versions of GraphRAG before 2.2.0 made extensive use of <code>max_tokens</code> and <code>logit_bias</code> to control generated response length or content. The introduction of the o-series of models added new, non-compatible parameters because these models include a reasoning component that has different consumption patterns and response generation attributes than non-reasoning models. GraphRAG 2.2.0 now supports these models, but there are important differences that need to be understood before you switch.</p> <ul> <li>Previously, GraphRAG used <code>max_tokens</code> to limit responses in a few locations. This is done so that we can have predictable content sizes when building downstream context windows for summarization. We have now switched from using <code>max_tokens</code> to use a prompted approach, which is working well in our tests. We suggest using <code>max_tokens</code> in your language model config only for budgetary reasons if you want to limit consumption, and not for expected response length control. We now also support the o-series equivalent <code>max_completion_tokens</code>, but if you use this keep in mind that there may be some unknown fixed reasoning consumption amount in addition to the response tokens, so it is not a good technique for response control.</li> <li>Previously, GraphRAG used a combination of <code>max_tokens</code> and <code>logit_bias</code> to strictly control a binary yes/no question during gleanings. This is not possible with reasoning models, so again we have switched to a prompted approach. Our tests with gpt-4o, gpt-4o-mini, and o1 show that this works consistently, but could have issues if you have an older or smaller model.</li> <li>The o-series models are much slower and more expensive. It may be useful to use an asymmetric approach to model use in your config: you can define as many models as you like in the <code>models</code> block of your settings.yaml and reference them by key for every workflow that requires a language model. You could use gpt-4o for indexing and o1 for query, for example. Experiment to find the right balance of cost, speed, and quality for your use case.</li> <li>The o-series models contain a form of native native chain-of-thought reasoning that is absent in the non-o-series models. GraphRAG's prompts sometimes contain CoT because it was an effective technique with the gpt-4* series. It may be counterproductive with the o-series, so you may want to tune or even re-write large portions of the prompt templates (particularly for graph and claim extraction).</li> </ul> <p>Example config with asymmetric model use:</p> <pre><code>models:\n  extraction_chat_model:\n    api_key: ${GRAPHRAG_API_KEY}\n    type: openai_chat\n    auth_type: api_key\n    model: gpt-4o\n    model_supports_json: true\n  query_chat_model:\n    api_key: ${GRAPHRAG_API_KEY}\n    type: openai_chat\n    auth_type: api_key\n    model: o1\n    model_supports_json: true\n\n...\n\nextract_graph:\n  model_id: extraction_chat_model\n  prompt: \"prompts/extract_graph.txt\"\n  entity_types: [organization,person,geo,event]\n  max_gleanings: 1\n\n...\n\n\nglobal_search:\n  chat_model_id: query_chat_model\n  map_prompt: \"prompts/global_search_map_system_prompt.txt\"\n  reduce_prompt: \"prompts/global_search_reduce_system_prompt.txt\"\n  knowledge_prompt: \"prompts/global_search_knowledge_system_prompt.txt\"\n</code></pre> <p>Another option would be to avoid using a language model at all for the graph extraction, instead using the <code>fast</code> indexing method that uses NLP for portions of the indexing phase in lieu of LLM APIs.</p>"}, {"location": "config/models/#using-non-openai-models", "title": "Using Non-OpenAI Models", "text": "<p>As shown above, non-OpenAI models may be used via LiteLLM starting with GraphRAG version 2.6.0 but cases may still exist in which some users wish to use models not supported by LiteLLM. There are two approaches one can use to connect to unsupported models:</p>"}, {"location": "config/models/#proxy-apis", "title": "Proxy APIs", "text": "<p>Many users have used platforms such as ollama and LiteLLM Proxy Server to proxy the underlying model HTTP calls to a different model provider. This seems to work reasonably well, but we frequently see issues with malformed responses (especially JSON), so if you do this please understand that your model needs to reliably return the specific response formats that GraphRAG expects. If you're having trouble with a model, you may need to try prompting to coax the format, or intercepting the response within your proxy to try and handle malformed responses.</p>"}, {"location": "config/models/#model-protocol", "title": "Model Protocol", "text": "<p>As of GraphRAG 2.0.0, we support model injection through the use of a standard chat and embedding Protocol and an accompanying ModelFactory that you can use to register your model implementation. This is not supported with the CLI, so you'll need to use GraphRAG as a library.</p> <ul> <li>Our Protocol is defined here</li> <li>Our base implementation, which wraps fnllm, is here</li> <li>We have a simple mock implementation in our tests that you can reference here</li> </ul> <p>Once you have a model implementation, you need to register it with our ModelFactory:</p> <pre><code>class MyCustomModel:\n    ...\n    # implementation\n\n# elsewhere...\nModelFactory.register_chat(\"my-custom-chat-model\", lambda **kwargs: MyCustomModel(**kwargs))\n</code></pre> <p>Then in your config you can reference the type name you used:</p> <pre><code>models:\n  default_chat_model:\n    type: my-custom-chat-model\n\n\nextract_graph:\n  model_id: default_chat_model\n  prompt: \"prompts/extract_graph.txt\"\n  entity_types: [organization,person,geo,event]\n  max_gleanings: 1\n</code></pre> <p>Note that your custom model will be passed the same params for init and method calls that we use throughout GraphRAG. There is not currently any ability to define custom parameters, so you may need to use closure scope or a factory pattern within your implementation to get custom config values.</p>"}, {"location": "config/overview/", "title": "Configuring GraphRAG Indexing", "text": "<p>The GraphRAG system is highly configurable. This page provides an overview of the configuration options available for the GraphRAG indexing engine.</p>"}, {"location": "config/overview/#default-configuration-mode", "title": "Default Configuration Mode", "text": "<p>The default configuration mode is the simplest way to get started with the GraphRAG system. It is designed to work out-of-the-box with minimal configuration. The main ways to set up GraphRAG in Default Configuration mode are via:</p> <ul> <li>Init command (recommended first step)</li> <li>Edit settings.yaml for deeper control</li> <li>Purely using environment variables (not recommended)</li> </ul>"}, {"location": "config/yaml/", "title": "Default Configuration Mode (using YAML/JSON)", "text": "<p>The default configuration mode may be configured by using a <code>settings.yml</code> or <code>settings.json</code> file in the data project root. If a <code>.env</code> file is present along with this config file, then it will be loaded, and the environment variables defined therein will be available for token replacements in your configuration document using <code>${ENV_VAR}</code> syntax. We initialize with YML by default in <code>graphrag init</code> but you may use the equivalent JSON form if preferred.</p> <p>Many of these config values have defaults. Rather than replicate them here, please refer to the constants in the code directly.</p> <p>For example:</p> <pre><code># .env\nGRAPHRAG_API_KEY=some_api_key\n\n# settings.yml\nllm: \n  api_key: ${GRAPHRAG_API_KEY}\n</code></pre>"}, {"location": "config/yaml/#config-sections", "title": "Config Sections", "text": ""}, {"location": "config/yaml/#language-model-setup", "title": "Language Model Setup", "text": ""}, {"location": "config/yaml/#models", "title": "models", "text": "<p>This is a dict of model configurations. The dict key is used to reference this configuration elsewhere when a model instance is desired. In this way, you can specify as many different models as you need, and reference them differentially in the workflow steps.</p> <p>For example: <pre><code>models:\n  default_chat_model:\n    api_key: ${GRAPHRAG_API_KEY}\n    type: openai_chat\n    model: gpt-4o\n    model_supports_json: true\n  default_embedding_model:\n    api_key: ${GRAPHRAG_API_KEY}\n    type: openai_embedding\n    model: text-embedding-ada-002\n</code></pre></p>"}, {"location": "config/yaml/#fields", "title": "Fields", "text": "<ul> <li><code>api_key</code> str - The OpenAI API key to use.</li> <li><code>auth_type</code> api_key|azure_managed_identity - Indicate how you want to authenticate requests.</li> <li><code>type</code> chat|embedding|openai_chat|azure_openai_chat|openai_embedding|azure_openai_embedding|mock_chat|mock_embeddings - The type of LLM to use.</li> <li><code>model_provider</code> str|None - The model provider to use, e.g., openai, azure, anthropic, etc. Required when <code>type == chat|embedding</code>. When <code>type == chat|embedding</code>, LiteLLM is used under the hood which has support for calling 100+ models. View LiteLLm basic usage for details on how models are called (The <code>model_provider</code> is the portion prior to <code>/</code> while the <code>model</code> is the portion following the <code>/</code>). View Language Model Selection for more details and examples on using LiteLLM.</li> <li><code>model</code> str - The model name.</li> <li><code>encoding_model</code> str - The text encoding model to use. Default is to use the encoding model aligned with the language model (i.e., it is retrieved from tiktoken if unset).</li> <li><code>api_base</code> str - The API base url to use.</li> <li><code>api_version</code> str - The API version.</li> <li><code>deployment_name</code> str - The deployment name to use (Azure).</li> <li><code>organization</code> str - The client organization.</li> <li><code>proxy</code> str - The proxy URL to use.</li> <li><code>audience</code> str - (Azure OpenAI only) The URI of the target Azure resource/service for which a managed identity token is requested. Used if <code>api_key</code> is not defined. Default=<code>https://cognitiveservices.azure.com/.default</code></li> <li><code>model_supports_json</code> bool - Whether the model supports JSON-mode output.</li> <li><code>request_timeout</code> float - The per-request timeout.</li> <li><code>tokens_per_minute</code> int - Set a leaky-bucket throttle on tokens-per-minute.</li> <li><code>requests_per_minute</code> int - Set a leaky-bucket throttle on requests-per-minute.</li> <li><code>retry_strategy</code> str - Retry strategy to use, \"native\" is the default and uses the strategy built into the OpenAI SDK. Other allowable values include \"exponential_backoff\", \"random_wait\", and \"incremental_wait\".</li> <li><code>max_retries</code> int - The maximum number of retries to use.</li> <li><code>max_retry_wait</code> float - The maximum backoff time.</li> <li><code>concurrent_requests</code> int The number of open requests to allow at once.</li> <li><code>async_mode</code> asyncio|threaded The async mode to use. Either <code>asyncio</code> or <code>threaded</code>.</li> <li><code>responses</code> list[str] - If this model type is mock, this is a list of response strings to return.</li> <li><code>n</code> int - The number of completions to generate.</li> <li><code>max_tokens</code> int - The maximum number of output tokens. Not valid for o-series models.</li> <li><code>temperature</code> float - The temperature to use. Not valid for o-series models.</li> <li><code>top_p</code> float - The top-p value to use. Not valid for o-series models.</li> <li><code>frequency_penalty</code> float - Frequency penalty for token generation. Not valid for o-series models.</li> <li><code>presence_penalty</code> float - Frequency penalty for token generation. Not valid for o-series models.</li> <li><code>max_completion_tokens</code> int - Max number of tokens to consume for chat completion. Must be large enough to include an unknown amount for \"reasoning\" by the model. o-series models only.</li> <li><code>reasoning_effort</code> low|medium|high - Amount of \"thought\" for the model to expend reasoning about a response. o-series models only.</li> </ul>"}, {"location": "config/yaml/#input-files-and-chunking", "title": "Input Files and Chunking", "text": ""}, {"location": "config/yaml/#input", "title": "input", "text": "<p>Our pipeline can ingest .csv, .txt, or .json data from an input location. See the inputs page for more details and examples.</p>"}, {"location": "config/yaml/#fields_1", "title": "Fields", "text": "<ul> <li><code>storage</code> StorageConfig</li> <li><code>type</code> file|blob|cosmosdb - The storage type to use. Default=<code>file</code></li> <li><code>base_dir</code> str - The base directory to write output artifacts to, relative to the root.</li> <li><code>connection_string</code> str - (blob/cosmosdb only) The Azure Storage connection string.</li> <li><code>container_name</code> str - (blob/cosmosdb only) The Azure Storage container name.</li> <li><code>storage_account_blob_url</code> str - (blob only) The storage account blob URL to use.</li> <li><code>cosmosdb_account_blob_url</code> str - (cosmosdb only) The CosmosDB account blob URL to use.</li> <li><code>file_type</code> text|csv|json - The type of input data to load. Default is <code>text</code></li> <li><code>encoding</code> str - The encoding of the input file. Default is <code>utf-8</code></li> <li><code>file_pattern</code> str - A regex to match input files. Default is <code>.*\\.csv$</code>, <code>.*\\.txt$</code>, or <code>.*\\.json$</code> depending on the specified <code>file_type</code>, but you can customize it if needed.</li> <li><code>file_filter</code> dict - Key/value pairs to filter. Default is None.</li> <li><code>text_column</code> str - (CSV/JSON only) The text column name. If unset we expect a column named <code>text</code>.</li> <li><code>title_column</code> str - (CSV/JSON only) The title column name, filename will be used if unset.</li> <li><code>metadata</code> list[str] - (CSV/JSON only) The additional document attributes fields to keep.</li> </ul>"}, {"location": "config/yaml/#chunks", "title": "chunks", "text": "<p>These settings configure how we parse documents into text chunks. This is necessary because very large documents may not fit into a single context window, and graph extraction accuracy can be modulated. Also note the <code>metadata</code> setting in the input document config, which will replicate document metadata into each chunk.</p>"}, {"location": "config/yaml/#fields_2", "title": "Fields", "text": "<ul> <li><code>size</code> int - The max chunk size in tokens.</li> <li><code>overlap</code> int - The chunk overlap in tokens.</li> <li><code>group_by_columns</code> list[str] - Group documents by these fields before chunking.</li> <li><code>strategy</code> str[tokens|sentences] - How to chunk the text. </li> <li><code>encoding_model</code> str - The text encoding model to use for splitting on token boundaries.</li> <li><code>prepend_metadata</code> bool - Determines if metadata values should be added at the beginning of each chunk. Default=<code>False</code>.</li> <li><code>chunk_size_includes_metadata</code> bool - Specifies whether the chunk size calculation should include metadata tokens. Default=<code>False</code>.</li> </ul>"}, {"location": "config/yaml/#outputs-and-storage", "title": "Outputs and Storage", "text": ""}, {"location": "config/yaml/#output", "title": "output", "text": "<p>This section controls the storage mechanism used by the pipeline used for exporting output tables.</p>"}, {"location": "config/yaml/#fields_3", "title": "Fields", "text": "<ul> <li><code>type</code> file|memory|blob|cosmosdb - The storage type to use. Default=<code>file</code></li> <li><code>base_dir</code> str - The base directory to write output artifacts to, relative to the root.</li> <li><code>connection_string</code> str - (blob/cosmosdb only) The Azure Storage connection string.</li> <li><code>container_name</code> str - (blob/cosmosdb only) The Azure Storage container name.</li> <li><code>storage_account_blob_url</code> str - (blob only) The storage account blob URL to use.</li> <li><code>cosmosdb_account_blob_url</code> str - (cosmosdb only) The CosmosDB account blob URL to use.</li> </ul>"}, {"location": "config/yaml/#update_index_output", "title": "update_index_output", "text": "<p>The section defines a secondary storage location for running incremental indexing, to preserve your original outputs.</p>"}, {"location": "config/yaml/#fields_4", "title": "Fields", "text": "<ul> <li><code>type</code> file|memory|blob|cosmosdb - The storage type to use. Default=<code>file</code></li> <li><code>base_dir</code> str - The base directory to write output artifacts to, relative to the root.</li> <li><code>connection_string</code> str - (blob/cosmosdb only) The Azure Storage connection string.</li> <li><code>container_name</code> str - (blob/cosmosdb only) The Azure Storage container name.</li> <li><code>storage_account_blob_url</code> str - (blob only) The storage account blob URL to use.</li> <li><code>cosmosdb_account_blob_url</code> str - (cosmosdb only) The CosmosDB account blob URL to use.</li> </ul>"}, {"location": "config/yaml/#cache", "title": "cache", "text": "<p>This section controls the cache mechanism used by the pipeline. This is used to cache LLM invocation results for faster performance when re-running the indexing process.</p>"}, {"location": "config/yaml/#fields_5", "title": "Fields", "text": "<ul> <li><code>type</code> file|memory|blob|cosmosdb - The storage type to use. Default=<code>file</code></li> <li><code>base_dir</code> str - The base directory to write output artifacts to, relative to the root.</li> <li><code>connection_string</code> str - (blob/cosmosdb only) The Azure Storage connection string.</li> <li><code>container_name</code> str - (blob/cosmosdb only) The Azure Storage container name.</li> <li><code>storage_account_blob_url</code> str - (blob only) The storage account blob URL to use.</li> <li><code>cosmosdb_account_blob_url</code> str - (cosmosdb only) The CosmosDB account blob URL to use.</li> </ul>"}, {"location": "config/yaml/#reporting", "title": "reporting", "text": "<p>This section controls the reporting mechanism used by the pipeline, for common events and error messages. The default is to write reports to a file in the output directory. However, you can also choose to write reports to an Azure Blob Storage container.</p>"}, {"location": "config/yaml/#fields_6", "title": "Fields", "text": "<ul> <li><code>type</code> file|blob - The reporting type to use. Default=<code>file</code></li> <li><code>base_dir</code> str - The base directory to write reports to, relative to the root.</li> <li><code>connection_string</code> str - (blob only) The Azure Storage connection string.</li> <li><code>container_name</code> str - (blob only) The Azure Storage container name.</li> <li><code>storage_account_blob_url</code> str - The storage account blob URL to use.</li> </ul>"}, {"location": "config/yaml/#vector_store", "title": "vector_store", "text": "<p>Where to put all vectors for the system. Configured for lancedb by default. This is a dict, with the key used to identify individual store parameters (e.g., for text embedding).</p>"}, {"location": "config/yaml/#fields_7", "title": "Fields", "text": "<ul> <li><code>type</code> lancedb|azure_ai_search|cosmosdb - Type of vector store. Default=<code>lancedb</code></li> <li><code>db_uri</code> str (only for lancedb) - The database uri. Default=<code>storage.base_dir/lancedb</code></li> <li><code>url</code> str (only for AI Search) - AI Search endpoint</li> <li><code>api_key</code> str (optional - only for AI Search) - The AI Search api key to use.</li> <li><code>audience</code> str (only for AI Search) - Audience for managed identity token if managed identity authentication is used.</li> <li><code>container_name</code> str - The name of a vector container. This stores all indexes (tables) for a given dataset ingest. Default=<code>default</code></li> <li><code>database_name</code> str - (cosmosdb only) Name of the database.</li> <li><code>overwrite</code> bool (only used at index creation time) - Overwrite collection if it exist. Default=<code>True</code></li> </ul>"}, {"location": "config/yaml/#workflow-configurations", "title": "Workflow Configurations", "text": "<p>These settings control each individual workflow as they execute.</p>"}, {"location": "config/yaml/#workflows", "title": "workflows", "text": "<p>list[str] - This is a list of workflow names to run, in order. GraphRAG has built-in pipelines to configure this, but you can run exactly and only what you want by specifying the list here. Useful if you have done part of the processing yourself.</p>"}, {"location": "config/yaml/#embed_text", "title": "embed_text", "text": "<p>By default, the GraphRAG indexer will only export embeddings required for our query methods. However, the model has embeddings defined for all plaintext fields, and these can be customized by setting the <code>target</code> and <code>names</code> fields.</p> <p>Supported embeddings names are:</p> <ul> <li><code>text_unit.text</code></li> <li><code>document.text</code></li> <li><code>entity.title</code></li> <li><code>entity.description</code></li> <li><code>relationship.description</code></li> <li><code>community.title</code></li> <li><code>community.summary</code></li> <li><code>community.full_content</code></li> </ul>"}, {"location": "config/yaml/#fields_8", "title": "Fields", "text": "<ul> <li><code>model_id</code> str - Name of the model definition to use for text embedding.</li> <li><code>vector_store_id</code> str - Name of vector store definition to write to.</li> <li><code>batch_size</code> int - The maximum batch size to use.</li> <li><code>batch_max_tokens</code> int - The maximum batch # of tokens.</li> <li><code>names</code> list[str] - List of the embeddings names to run (must be in supported list).</li> </ul>"}, {"location": "config/yaml/#extract_graph", "title": "extract_graph", "text": "<p>Tune the language model-based graph extraction process.</p>"}, {"location": "config/yaml/#fields_9", "title": "Fields", "text": "<ul> <li><code>model_id</code> str - Name of the model definition to use for API calls.</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>entity_types</code> list[str] - The entity types to identify.</li> <li><code>max_gleanings</code> int - The maximum number of gleaning cycles to use.</li> </ul>"}, {"location": "config/yaml/#summarize_descriptions", "title": "summarize_descriptions", "text": ""}, {"location": "config/yaml/#fields_10", "title": "Fields", "text": "<ul> <li><code>model_id</code> str - Name of the model definition to use for API calls.</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>max_length</code> int - The maximum number of output tokens per summarization.</li> <li><code>max_input_length</code> int - The maximum number of tokens to collect for summarization (this will limit how many descriptions you send to be summarized for a given entity or relationship).</li> </ul>"}, {"location": "config/yaml/#extract_graph_nlp", "title": "extract_graph_nlp", "text": "<p>Defines settings for NLP-based graph extraction methods.</p>"}, {"location": "config/yaml/#fields_11", "title": "Fields", "text": "<ul> <li><code>normalize_edge_weights</code> bool - Whether to normalize the edge weights during graph construction. Default=<code>True</code>.</li> <li><code>text_analyzer</code> dict - Parameters for the NLP model.</li> <li>extractor_type regex_english|syntactic_parser|cfg - Default=<code>regex_english</code>.</li> <li>model_name str - Name of NLP model (for SpaCy-based models)</li> <li>max_word_length int - Longest word to allow. Default=<code>15</code>.</li> <li>word_delimiter str - Delimiter to split words. Default ' '.</li> <li>include_named_entities bool - Whether to include named entities in noun phrases. Default=<code>True</code>.</li> <li>exclude_nouns list[str] | None - List of nouns to exclude. If <code>None</code>, we use an internal stopword list.</li> <li>exclude_entity_tags list[str] - List of entity tags to ignore.</li> <li>exclude_pos_tags list[str] - List of part-of-speech tags to ignore.</li> <li>noun_phrase_tags list[str] - List of noun phrase tags to ignore.</li> <li>noun_phrase_grammars dict[str, str] - Noun phrase grammars for the model (cfg-only).</li> </ul>"}, {"location": "config/yaml/#prune_graph", "title": "prune_graph", "text": "<p>Parameters for manual graph pruning. This can be used to optimize the modularity of your graph clusters, by removing overly-connected or rare nodes.</p>"}, {"location": "config/yaml/#fields_12", "title": "Fields", "text": "<ul> <li>min_node_freq int - The minimum node frequency to allow.</li> <li>max_node_freq_std float | None - The maximum standard deviation of node frequency to allow.</li> <li>min_node_degree int - The minimum node degree to allow.</li> <li>max_node_degree_std float | None - The maximum standard deviation of node degree to allow.</li> <li>min_edge_weight_pct float - The minimum edge weight percentile to allow.</li> <li>remove_ego_nodes bool - Remove ego nodes.</li> <li>lcc_only bool - Only use largest connected component.</li> </ul>"}, {"location": "config/yaml/#cluster_graph", "title": "cluster_graph", "text": "<p>These are the settings used for Leiden hierarchical clustering of the graph to create communities.</p>"}, {"location": "config/yaml/#fields_13", "title": "Fields", "text": "<ul> <li><code>max_cluster_size</code> int - The maximum cluster size to export.</li> <li><code>use_lcc</code> bool - Whether to only use the largest connected component.</li> <li><code>seed</code> int - A randomization seed to provide if consistent run-to-run results are desired. We do provide a default in order to guarantee clustering stability.</li> </ul>"}, {"location": "config/yaml/#extract_claims", "title": "extract_claims", "text": ""}, {"location": "config/yaml/#fields_14", "title": "Fields", "text": "<ul> <li><code>enabled</code> bool - Whether to enable claim extraction. Off by default, because claim prompts really need user tuning.</li> <li><code>model_id</code> str - Name of the model definition to use for API calls.</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>description</code> str - Describes the types of claims we want to extract.</li> <li><code>max_gleanings</code> int - The maximum number of gleaning cycles to use.</li> </ul>"}, {"location": "config/yaml/#community_reports", "title": "community_reports", "text": ""}, {"location": "config/yaml/#fields_15", "title": "Fields", "text": "<ul> <li><code>model_id</code> str - Name of the model definition to use for API calls.</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>max_length</code> int - The maximum number of output tokens per report.</li> <li><code>max_input_length</code> int - The maximum number of input tokens to use when generating reports.</li> </ul>"}, {"location": "config/yaml/#embed_graph", "title": "embed_graph", "text": "<p>We use node2vec to embed the graph. This is primarily used for visualization, so it is not turned on by default.</p>"}, {"location": "config/yaml/#fields_16", "title": "Fields", "text": "<ul> <li><code>enabled</code> bool - Whether to enable graph embeddings.</li> <li><code>dimensions</code> int - Number of vector dimensions to produce.</li> <li><code>num_walks</code> int - The node2vec number of walks.</li> <li><code>walk_length</code> int - The node2vec walk length.</li> <li><code>window_size</code> int - The node2vec window size.</li> <li><code>iterations</code> int - The node2vec number of iterations.</li> <li><code>random_seed</code> int - The node2vec random seed.</li> <li><code>strategy</code> dict - Fully override the embed graph strategy.</li> </ul>"}, {"location": "config/yaml/#umap", "title": "umap", "text": "<p>Indicates whether we should run UMAP dimensionality reduction. This is used to provide an x/y coordinate to each graph node, suitable for visualization. If this is not enabled, nodes will receive a 0/0 x/y coordinate. If this is enabled, you must enable graph embedding as well.</p>"}, {"location": "config/yaml/#fields_17", "title": "Fields", "text": "<ul> <li><code>enabled</code> bool - Whether to enable UMAP layouts.</li> </ul>"}, {"location": "config/yaml/#snapshots", "title": "snapshots", "text": ""}, {"location": "config/yaml/#fields_18", "title": "Fields", "text": "<ul> <li><code>embeddings</code> bool - Export embeddings snapshots to parquet.</li> <li><code>graphml</code> bool - Export graph snapshots to GraphML.</li> </ul>"}, {"location": "config/yaml/#query", "title": "Query", "text": ""}, {"location": "config/yaml/#local_search", "title": "local_search", "text": ""}, {"location": "config/yaml/#fields_19", "title": "Fields", "text": "<ul> <li><code>chat_model_id</code> str - Name of the model definition to use for Chat Completion calls.</li> <li><code>embedding_model_id</code> str - Name of the model definition to use for Embedding calls.</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>text_unit_prop</code> float - The text unit proportion. </li> <li><code>community_prop</code> float - The community proportion.</li> <li><code>conversation_history_max_turns</code> int - The conversation history maximum turns.</li> <li><code>top_k_entities</code> int - The top k mapped entities.</li> <li><code>top_k_relationships</code> int - The top k mapped relations.</li> <li><code>max_context_tokens</code> int - The maximum tokens to use building the request context.</li> </ul>"}, {"location": "config/yaml/#global_search", "title": "global_search", "text": ""}, {"location": "config/yaml/#fields_20", "title": "Fields", "text": "<ul> <li><code>chat_model_id</code> str - Name of the model definition to use for Chat Completion calls.</li> <li><code>map_prompt</code> str - The mapper prompt file to use.</li> <li><code>reduce_prompt</code> str - The reducer prompt file to use.</li> <li><code>knowledge_prompt</code> str - The knowledge prompt file to use.</li> <li><code>map_prompt</code> str | None - The global search mapper prompt to use.</li> <li><code>reduce_prompt</code> str | None - The global search reducer to use.</li> <li><code>knowledge_prompt</code> str | None - The global search general prompt to use.</li> <li><code>max_context_tokens</code> int - The maximum context size to create, in tokens.</li> <li><code>data_max_tokens</code> int - The maximum tokens to use constructing the final response from the reduces responses.</li> <li><code>map_max_length</code> int - The maximum length to request for map responses, in words.</li> <li><code>reduce_max_length</code> int - The maximum length to request for reduce responses, in words.</li> <li><code>dynamic_search_threshold</code> int - Rating threshold in include a community report.</li> <li><code>dynamic_search_keep_parent</code> bool - Keep parent community if any of the child communities are relevant.</li> <li><code>dynamic_search_num_repeats</code> int - Number of times to rate the same community report.</li> <li><code>dynamic_search_use_summary</code> bool - Use community summary instead of full_context.</li> <li><code>dynamic_search_max_level</code> int - The maximum level of community hierarchy to consider if none of the processed communities are relevant.</li> </ul>"}, {"location": "config/yaml/#drift_search", "title": "drift_search", "text": ""}, {"location": "config/yaml/#fields_21", "title": "Fields", "text": "<ul> <li><code>chat_model_id</code> str - Name of the model definition to use for Chat Completion calls.</li> <li><code>embedding_model_id</code> str - Name of the model definition to use for Embedding calls.</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>reduce_prompt</code> str - The reducer prompt file to use.</li> <li><code>data_max_tokens</code> int - The data llm maximum tokens.</li> <li><code>reduce_max_tokens</code> int - The maximum tokens for the reduce phase. Only use if a non-o-series model.</li> <li><code>reduce_max_completion_tokens</code> int - The maximum tokens for the reduce phase. Only use for o-series models.</li> <li><code>concurrency</code> int - The number of concurrent requests.</li> <li><code>drift_k_followups</code> int - The number of top global results to retrieve.</li> <li><code>primer_folds</code> int - The number of folds for search priming.</li> <li><code>primer_llm_max_tokens</code> int - The maximum number of tokens for the LLM in primer.</li> <li><code>n_depth</code> int - The number of drift search steps to take.</li> <li><code>local_search_text_unit_prop</code> float - The proportion of search dedicated to text units.</li> <li><code>local_search_community_prop</code> float - The proportion of search dedicated to community properties.</li> <li><code>local_search_top_k_mapped_entities</code> int - The number of top K entities to map during local search.</li> <li><code>local_search_top_k_relationships</code> int - The number of top K relationships to map during local search.</li> <li><code>local_search_max_data_tokens</code> int - The maximum context size in tokens for local search.</li> <li><code>local_search_temperature</code> float - The temperature to use for token generation in local search.</li> <li><code>local_search_top_p</code> float - The top-p value to use for token generation in local search.</li> <li><code>local_search_n</code> int - The number of completions to generate in local search.</li> <li><code>local_search_llm_max_gen_tokens</code> int - The maximum number of generated tokens for the LLM in local search. Only use if a non-o-series model.</li> <li><code>local_search_llm_max_gen_completion_tokens</code> int - The maximum number of generated tokens for the LLM in local search. Only use for o-series models.</li> </ul>"}, {"location": "config/yaml/#basic_search", "title": "basic_search", "text": ""}, {"location": "config/yaml/#fields_22", "title": "Fields", "text": "<ul> <li><code>chat_model_id</code> str - Name of the model definition to use for Chat Completion calls.</li> <li><code>embedding_model_id</code> str - Name of the model definition to use for Embedding calls.</li> <li><code>prompt</code> str - The prompt file to use.</li> <li><code>k</code> int | None - Number of text units to retrieve from the vector store for context building.</li> </ul>"}, {"location": "data/operation_dulce/ABOUT/", "title": "About", "text": "<p>This document (Operation Dulce) is an AI-generated science fiction novella, included here for the purposes of integration testing.</p>"}, {"location": "index/architecture/", "title": "Indexing Architecture", "text": ""}, {"location": "index/architecture/#key-concepts", "title": "Key Concepts", "text": ""}, {"location": "index/architecture/#knowledge-model", "title": "Knowledge Model", "text": "<p>In order to support the GraphRAG system, the outputs of the indexing engine (in the Default Configuration Mode) are aligned to a knowledge model we call the GraphRAG Knowledge Model. This model is designed to be an abstraction over the underlying data storage technology, and to provide a common interface for the GraphRAG system to interact with. In normal use-cases the outputs of the GraphRAG Indexer would be loaded into a database system, and the GraphRAG's Query Engine would interact with the database using the knowledge model data-store types.</p>"}, {"location": "index/architecture/#workflows", "title": "Workflows", "text": "<p>Because of the complexity of our data indexing tasks, we needed to be able to express our data pipeline as series of multiple, interdependent workflows.</p> <pre><code>---\ntitle: Sample Workflow DAG\n---\nstateDiagram-v2\n    [*] --&gt; Prepare\n    Prepare --&gt; Chunk\n    Chunk --&gt; ExtractGraph\n    Chunk --&gt; EmbedDocuments\n    ExtractGraph --&gt; GenerateReports\n    ExtractGraph --&gt; EmbedEntities\n    ExtractGraph --&gt; EmbedGraph</code></pre>"}, {"location": "index/architecture/#llm-caching", "title": "LLM Caching", "text": "<p>The GraphRAG library was designed with LLM interactions in mind, and a common setback when working with LLM APIs is various errors due to network latency, throttling, etc.. Because of these potential error cases, we've added a cache layer around LLM interactions. When completion requests are made using the same input set (prompt and tuning parameters), we return a cached result if one exists. This allows our indexer to be more resilient to network issues, to act idempotently, and to provide a more efficient end-user experience.</p>"}, {"location": "index/architecture/#providers-factories", "title": "Providers &amp; Factories", "text": "<p>Several subsystems within GraphRAG use a factory pattern to register and retrieve provider implementations. This allows deep customization to support models, storage, and so on that you may use but isn't built directly into GraphRAG.</p> <p>The following subsystems use a factory pattern that allows you to register your own implementations:</p> <ul> <li>language model - implement your own <code>chat</code> and <code>embed</code> methods to use a model provider of choice beyond the built-in OpenAI/Azure support</li> <li>cache - create your own cache storage location in addition to the file, blob, and CosmosDB ones we provide</li> <li>logger - create your own log writing location in addition to the built-in file and blob storage</li> <li>storage - create your own storage provider (database, etc.) beyond the file, blob, and CosmosDB ones built in</li> <li>vector store - implement your own vector store other than the built-in lancedb, Azure AI Search, and CosmosDB ones built in</li> <li>pipeline + workflows - implement your own workflow steps with a custom <code>run_workflow</code> function, or register an entire pipeline (list of named workflows)</li> </ul> <p>The links for each of these subsystems point to the source code of the factory, which includes registration of the default built-in implementations. In addition, we have a detailed discussion of language models, which includes and example of a custom provider, and a sample notebook that demonstrates a custom vector store.</p> <p>All of these factories allow you to register an impl using any string name you would like, even overriding built-in ones directly.</p>"}, {"location": "index/byog/", "title": "Bring Your Own Graph", "text": "<p>Several users have asked if they can bring their own existing graph and have it summarized for query with GraphRAG. There are many possible ways to do this, but here we'll describe a simple method that aligns with the existing GraphRAG workflows quite easily.</p> <p>To cover the basic use cases for GraphRAG query, you should have two or three tables derived from your data:</p> <ul> <li>entities.parquet - this is the list of entities found in the dataset, which are the nodes of the graph.</li> <li>relationships.parquet - this is the list of relationships found in the dataset, which are the edges of the graph.</li> <li>text_units.parquet - this is the source text chunks the graph was extracted from. This is optional depending on the query method you intend to use (described later).</li> </ul> <p>The approach described here will be to run a custom GraphRAG workflow pipeline that assumes the text chunking, entity extraction, and relationship extraction has already occurred.</p>"}, {"location": "index/byog/#tables", "title": "Tables", "text": ""}, {"location": "index/byog/#entities", "title": "Entities", "text": "<p>See the full entities table schema. For graph summarization purposes, you only need id, title, description, and the list of text_unit_ids.</p> <p>The additional properties are used for optional graph visualization purposes.</p>"}, {"location": "index/byog/#relationships", "title": "Relationships", "text": "<p>See the full relationships table schema. For graph summarization purposes, you only need id, source, target, description, weight, and the list of text_unit_ids.</p> <p>Note: the <code>weight</code> field is important because it is used to properly compute Leiden communities!</p>"}, {"location": "index/byog/#workflow-configuration", "title": "Workflow Configuration", "text": "<p>GraphRAG includes the ability to specify only the specific workflow steps that you need. For basic graph summarization and query, you need the following config in your settings.yaml:</p> <pre><code>workflows: [create_communities, create_community_reports]\n</code></pre> <p>This will result in only the minimal workflows required for GraphRAG Global Search.</p>"}, {"location": "index/byog/#optional-additional-config", "title": "Optional Additional Config", "text": "<p>If you would like to run Local, DRIFT, or Basic Search, you will need to include text_units and some embeddings.</p>"}, {"location": "index/byog/#text-units", "title": "Text Units", "text": "<p>See the full text_units table schema. Text units are chunks of your documents that are sized to ensure they fit into the context window of your model. Some search methods use these, so you may want to include them if you have them.</p>"}, {"location": "index/byog/#expanded-config", "title": "Expanded Config", "text": "<p>To perform the other search types above, you need some of the content to be embedded. Simply add the embeddings workflow:</p> <pre><code>workflows: [create_communities, create_community_reports, generate_text_embeddings]\n</code></pre>"}, {"location": "index/byog/#fastgraphrag", "title": "FastGraphRAG", "text": "<p>FastGraphRAG uses text_units for the community reports instead of the entity and relationship descriptions. If your graph is sourced in such a way that it does not have descriptions, this might be a useful alternative. In this case, you would update your workflows list to include the text variant of the community reports workflow:</p> <pre><code>workflows: [create_communities, create_community_reports_text, generate_text_embeddings]\n</code></pre> <p>This method requires that your entities and relationships tables have valid links to a list of text_unit_ids. Also note that <code>generate_text_embeddings</code> is still only required if you are doing searches other than Global Search.</p>"}, {"location": "index/byog/#setup", "title": "Setup", "text": "<p>Putting it all together:</p> <ul> <li><code>output</code>: Create an output folder and put your entities and relationships (and optionally text_units) parquet files in it.</li> <li>Update your config as noted above to only run the workflows subset you need.</li> <li>Run <code>graphrag index --root &lt;your project root&gt;</code></li> </ul>"}, {"location": "index/default_dataflow/", "title": "Indexing Dataflow", "text": ""}, {"location": "index/default_dataflow/#the-graphrag-knowledge-model", "title": "The GraphRAG Knowledge Model", "text": "<p>The knowledge model is a specification for data outputs that conform to our data-model definition. You can find these definitions in the python/graphrag/graphrag/model folder within the GraphRAG repository. The following entity types are provided. The fields here represent the fields that are text-embedded by default.</p> <ul> <li><code>Document</code> - An input document into the system. These either represent individual rows in a CSV or individual .txt file.</li> <li><code>TextUnit</code> - A chunk of text to analyze. The size of these chunks, their overlap, and whether they adhere to any data boundaries may be configured below. A common use case is to set <code>CHUNK_BY_COLUMNS</code> to <code>id</code> so that there is a 1-to-many relationship between documents and TextUnits instead of a many-to-many.</li> <li><code>Entity</code> - An entity extracted from a TextUnit. These represent people, places, events, or some other entity-model that you provide.</li> <li><code>Relationship</code> - A relationship between two entities.</li> <li><code>Covariate</code> - Extracted claim information, which contains statements about entities which may be time-bound.</li> <li><code>Community</code> - Once the graph of entities and relationships is built, we perform hierarchical community detection on them to create a clustering structure.</li> <li><code>Community Report</code> - The contents of each community are summarized into a generated report, useful for human reading and downstream search.</li> </ul>"}, {"location": "index/default_dataflow/#the-default-configuration-workflow", "title": "The Default Configuration Workflow", "text": "<p>Let's take a look at how the default-configuration workflow transforms text documents into the GraphRAG Knowledge Model. This page gives a general overview of the major steps in this process. To fully configure this workflow, check out the configuration documentation.</p> <pre><code>---\ntitle: Dataflow Overview\n---\nflowchart TB\n    subgraph phase1[Phase 1: Compose TextUnits]\n    documents[Documents] --&gt; chunk[Chunk]\n    chunk --&gt; textUnits[Text Units]\n    end\n    subgraph phase2[Phase 2: Graph Extraction]\n    textUnits --&gt; graph_extract[Entity &amp; Relationship Extraction]\n    graph_extract --&gt; graph_summarize[Entity &amp; Relationship Summarization]\n    graph_summarize --&gt; claim_extraction[Claim Extraction]\n    claim_extraction --&gt; graph_outputs[Graph Tables]\n    end\n    subgraph phase3[Phase 3: Graph Augmentation]\n    graph_outputs --&gt; community_detect[Community Detection]\n    community_detect --&gt; community_outputs[Communities Table]\n    end\n    subgraph phase4[Phase 4: Community Summarization]\n    community_outputs --&gt; summarized_communities[Community Summarization]\n    summarized_communities --&gt; community_report_outputs[Community Reports Table]\n    end\n    subgraph phase5[Phase 5: Document Processing]\n    documents --&gt; link_to_text_units[Link to TextUnits]\n    textUnits --&gt; link_to_text_units\n    link_to_text_units --&gt; document_outputs[Documents Table]\n    end\n    subgraph phase6[Phase 6: Network Visualization]\n    graph_outputs --&gt; graph_embed[Graph Embedding]\n    graph_embed --&gt; umap_entities[Umap Entities]\n    umap_entities --&gt; combine_nodes[Final Entities]\n    end\n    subgraph phase7[Phase 7: Text Embeddings]\n    textUnits --&gt; text_embed[Text Embedding]\n    graph_outputs --&gt; description_embed[Description Embedding]\n    community_report_outputs --&gt; content_embed[Content Embedding]\n    end</code></pre>"}, {"location": "index/default_dataflow/#phase-1-compose-textunits", "title": "Phase 1: Compose TextUnits", "text": "<p>The first phase of the default-configuration workflow is to transform input documents into TextUnits. A TextUnit is a chunk of text that is used for our graph extraction techniques. They are also used as source-references by extracted knowledge items in order to empower breadcrumbs and provenance by concepts back to their original source text.</p> <p>The chunk size (counted in tokens), is user-configurable. By default this is set to 300 tokens, although we've had positive experience with 1200-token chunks using a single \"glean\" step. (A \"glean\" step is a follow-on extraction). Larger chunks result in lower-fidelity output and less meaningful reference texts; however, using larger chunks can result in much faster processing time.</p> <p>The group-by configuration is also user-configurable. By default, we align our chunks to document boundaries, meaning that there is a strict 1-to-many relationship between Documents and TextUnits. In rare cases, this can be turned into a many-to-many relationship. This is useful when the documents are very short and we need several of them to compose a meaningful analysis unit (e.g. Tweets or a chat log)</p> <pre><code>---\ntitle: Documents into Text Chunks\n---\nflowchart LR\n    doc1[Document 1] --&gt; tu1[TextUnit 1]\n    doc1 --&gt; tu2[TextUnit 2]\n    doc2[Document 2] --&gt; tu3[TextUnit 3]\n    doc2 --&gt; tu4[TextUnit 4]\n</code></pre>"}, {"location": "index/default_dataflow/#phase-2-graph-extraction", "title": "Phase 2: Graph Extraction", "text": "<p>In this phase, we analyze each text unit and extract our graph primitives: Entities, Relationships, and Claims. Entities and Relationships are extracted at once in our entity_extract verb, and claims are extracted in our claim_extract verb. Results are then combined and passed into following phases of the pipeline.</p> <pre><code>---\ntitle: Graph Extraction\n---\nflowchart LR\n    tu[TextUnit] --&gt; ge[Graph Extraction] --&gt; gs[Graph Summarization]\n    tu --&gt; ce[Claim Extraction]</code></pre>"}, {"location": "index/default_dataflow/#entity-relationship-extraction", "title": "Entity &amp; Relationship Extraction", "text": "<p>In this first step of graph extraction, we process each text-unit in order to extract entities and relationships out of the raw text using the LLM. The output of this step is a subgraph-per-TextUnit containing a list of entities with a title, type, and description, and a list of relationships with a source, target, and description.</p> <p>These subgraphs are merged together - any entities with the same title and type are merged by creating an array of their descriptions. Similarly, any relationships with the same source and target are merged by creating an array of their descriptions.</p>"}, {"location": "index/default_dataflow/#entity-relationship-summarization", "title": "Entity &amp; Relationship Summarization", "text": "<p>Now that we have a graph of entities and relationships, each with a list of descriptions, we can summarize these lists into a single description per entity and relationship. This is done by asking the LLM for a short summary that captures all of the distinct information from each description. This allows all of our entities and relationships to have a single concise description.</p>"}, {"location": "index/default_dataflow/#claim-extraction-optional", "title": "Claim Extraction (optional)", "text": "<p>Finally, as an independent workflow, we extract claims from the source TextUnits. These claims represent positive factual statements with an evaluated status and time-bounds. These get exported as a primary artifact called Covariates.</p> <p>Note: claim extraction is optional and turned off by default. This is because claim extraction generally requires prompt tuning to be useful.</p>"}, {"location": "index/default_dataflow/#phase-3-graph-augmentation", "title": "Phase 3: Graph Augmentation", "text": "<p>Now that we have a usable graph of entities and relationships, we want to understand their community structure. These give us explicit ways of understanding the topological structure of our graph.</p> <pre><code>---\ntitle: Graph Augmentation\n---\nflowchart LR\n    cd[Leiden Hierarchical Community Detection] --&gt; ag[Graph Tables]</code></pre>"}, {"location": "index/default_dataflow/#community-detection", "title": "Community Detection", "text": "<p>In this step, we generate a hierarchy of entity communities using the Hierarchical Leiden Algorithm. This method will apply a recursive community-clustering to our graph until we reach a community-size threshold. This will allow us to understand the community structure of our graph and provide a way to navigate and summarize the graph at different levels of granularity.</p>"}, {"location": "index/default_dataflow/#graph-tables", "title": "Graph Tables", "text": "<p>Once our graph augmentation steps are complete, the final Entities, Relationships, and Communities tables are exported.</p>"}, {"location": "index/default_dataflow/#phase-4-community-summarization", "title": "Phase 4: Community Summarization", "text": "<pre><code>---\ntitle: Community Summarization\n---\nflowchart LR\n    sc[Generate Community Reports] --&gt; ss[Summarize Community Reports] --&gt; co[Community Reports Table]</code></pre> <p>At this point, we have a functional graph of entities and relationships and a hierarchy of communities for the entities.</p> <p>Now we want to build on the communities data and generate reports for each community. This gives us a high-level understanding of the graph at several points of graph granularity. For example, if community A is the top-level community, we'll get a report about the entire graph. If the community is lower-level, we'll get a report about a local cluster.</p>"}, {"location": "index/default_dataflow/#generate-community-reports", "title": "Generate Community Reports", "text": "<p>In this step, we generate a summary of each community using the LLM. This will allow us to understand the distinct information contained within each community and provide a scoped understanding of the graph, from either a high-level or a low-level perspective. These reports contain an executive overview and reference the key entities, relationships, and claims within the community sub-structure.</p>"}, {"location": "index/default_dataflow/#summarize-community-reports", "title": "Summarize Community Reports", "text": "<p>In this step, each community report is then summarized via the LLM for shorthand use.</p>"}, {"location": "index/default_dataflow/#community-reports-table", "title": "Community Reports Table", "text": "<p>At this point, some bookkeeping work is performed and we export the Community Reports tables.</p>"}, {"location": "index/default_dataflow/#phase-5-document-processing", "title": "Phase 5: Document Processing", "text": "<p>In this phase of the workflow, we create the Documents table for the knowledge model.</p> <pre><code>---\ntitle: Document Processing\n---\nflowchart LR\n    aug[Augment] --&gt; dp[Link to TextUnits] --&gt; dg[Documents Table]</code></pre>"}, {"location": "index/default_dataflow/#augment-with-columns-csv-only", "title": "Augment with Columns (CSV Only)", "text": "<p>If the workflow is operating on CSV data, you may configure your workflow to add additional fields to Documents output. These fields should exist on the incoming CSV tables. Details about configuring this can be found in the configuration documentation.</p>"}, {"location": "index/default_dataflow/#link-to-textunits", "title": "Link to TextUnits", "text": "<p>In this step, we link each document to the text-units that were created in the first phase. This allows us to understand which documents are related to which text-units and vice-versa.</p>"}, {"location": "index/default_dataflow/#documents-table", "title": "Documents Table", "text": "<p>At this point, we can export the Documents table into the knowledge Model.</p>"}, {"location": "index/default_dataflow/#phase-6-network-visualization-optional", "title": "Phase 6: Network Visualization (optional)", "text": "<p>In this phase of the workflow, we perform some steps to support network visualization of our high-dimensional vector spaces within our existing graphs. At this point there are two logical graphs at play: the Entity-Relationship graph and the Document graph.</p> <pre><code>---\ntitle: Network Visualization Workflows\n---\nflowchart LR\n    ag[Graph Table] --&gt; ge[Node2Vec Graph Embedding] --&gt; ne[Umap Entities] --&gt; ng[Entities Table]</code></pre>"}, {"location": "index/default_dataflow/#graph-embedding", "title": "Graph Embedding", "text": "<p>In this step, we generate a vector representation of our graph using the Node2Vec algorithm. This will allow us to understand the implicit structure of our graph and provide an additional vector-space in which to search for related concepts during our query phase.</p>"}, {"location": "index/default_dataflow/#dimensionality-reduction", "title": "Dimensionality Reduction", "text": "<p>For each of the logical graphs, we perform a UMAP dimensionality reduction to generate a 2D representation of the graph. This will allow us to visualize the graph in a 2D space and understand the relationships between the nodes in the graph. The UMAP embeddings are reduced to two dimensions as x/y coordinates.</p>"}, {"location": "index/default_dataflow/#phase-7-text-embedding", "title": "Phase 7: Text Embedding", "text": "<p>For all artifacts that require downstream vector search, we generate text embeddings as a final step. These embeddings are written directly to a configured vector store. By default we embed entity descriptions, text unit text, and community report text.</p> <pre><code>---\ntitle: Text Embedding Workflows\n---\nflowchart LR\n    textUnits[Text Units] --&gt; text_embed[Text Embedding]\n    graph_outputs[Graph Tables] --&gt; description_embed[Description Embedding]\n    community_report_outputs[Community Reports] --&gt; content_embed[Content Embedding]</code></pre>"}, {"location": "index/inputs/", "title": "Inputs", "text": "<p>GraphRAG supports several input formats to simplify ingesting your data. The mechanics and features available for input files and text chunking are discussed here.</p>"}, {"location": "index/inputs/#input-loading-and-schema", "title": "Input Loading and Schema", "text": "<p>All input formats are loaded within GraphRAG and passed to the indexing pipeline as a <code>documents</code> DataFrame. This DataFrame has a row for each document using a shared column schema:</p> name type description id str ID of the document. This is generated using a hash of the text content to ensure stability across runs. text str The full text of the document. title str Name of the document. Some formats allow this to be configured. creation_date str The creation date of the document, represented as an ISO8601 string. This is harvested from the source file system. metadata dict Optional additional document metadata. More details below. <p>Also see the outputs documentation for the final documents table schema saved to parquet after pipeline completion.</p>"}, {"location": "index/inputs/#bring-your-own-dataframe", "title": "Bring-your-own DataFrame", "text": "<p>As of version 2.6.0, GraphRAG's indexing API method allows you to pass in your own pandas DataFrame and bypass all of the input loading/parsing described in the next section. This is convenient if you have content in a format or storage location we don't support out-of-the-box. You must ensure that your input DataFrame conforms to the schema described above. All of the chunking behavior described later will proceed exactly the same.</p>"}, {"location": "index/inputs/#formats", "title": "Formats", "text": "<p>We support three file formats out-of-the-box. This covers the overwhelming majority of use cases we have encountered. If you have a different format, we recommend writing a script to convert to one of these, which are widely used and supported by many tools and libraries.</p>"}, {"location": "index/inputs/#plain-text", "title": "Plain Text", "text": "<p>Plain text files (typically ending in .txt file extension). With plain text files we import the entire file contents as the <code>text</code> field, and the <code>title</code> is always the filename.</p>"}, {"location": "index/inputs/#comma-delimited", "title": "Comma-delimited", "text": "<p>CSV files (typically ending in a .csv extension). These are loaded using pandas' <code>read_csv</code> method with default options. Each row in a CSV file is treated as a single document. If you have multiple CSV files in your input folder, they will be concatenated into a single resulting <code>documents</code> DataFrame.</p> <p>With the CSV format you can configure the <code>text_column</code>, and <code>title_column</code> if your data has structured content you would prefer to use. If you do not configure these within the <code>input</code> block of your settings.yaml, the title will be the filename as described in the schema above. The <code>text_column</code> is assumed to be \"text\" in your file if not configured specifically. We will also look for and use an \"id\" column if present, otherwise the ID will be generated as described above.</p>"}, {"location": "index/inputs/#json", "title": "JSON", "text": "<p>JSON files (typically ending in a .json extension) contain structured objects. These are loaded using python's <code>json.loads</code> method, so your files must be properly compliant. JSON files may contain a single object in the file or the file may contain an array of objects at the root. We will check for and handle either of these cases. As with CSV, multiple files will be concatenated into a final table, and the <code>text_column</code> and <code>title_column</code> config options will be applied to the properties of each loaded object. Note that the specialized jsonl format produced by some libraries (one full JSON object on each line, not in an array) is not currently supported.</p>"}, {"location": "index/inputs/#metadata", "title": "Metadata", "text": "<p>With the structured file formats (CSV and JSON) you can configure any number of columns to be added to a persisted <code>metadata</code> field in the DataFrame. This is configured by supplying a list of columns name to collect. If this is configured, the output <code>metadata</code> column will have a dict containing a key for each column, and the value of the column for that document. This metadata can optionally be used later in the GraphRAG pipeline.</p>"}, {"location": "index/inputs/#example", "title": "Example", "text": "<p>software.csv</p> <pre><code>text,title,tag\nMy first program,Hello World,tutorial\nAn early space shooter game,Space Invaders,arcade\n</code></pre> <p>settings.yaml</p> <pre><code>input:\n    metadata: [title,tag]\n</code></pre> <p>Documents DataFrame</p> id title text creation_date metadata (generated from text) Hello World My first program (create date of software.csv) { \"title\": \"Hello World\", \"tag\": \"tutorial\" } (generated from text) Space Invaders An early space shooter game (create date of software.csv) { \"title\": \"Space Invaders\", \"tag\": \"arcade\" }"}, {"location": "index/inputs/#chunking-and-metadata", "title": "Chunking and Metadata", "text": "<p>As described on the default dataflow page, documents are chunked into smaller \"text units\" for processing. This is done because document content size often exceeds the available context window for a given language model. There are a handful of settings you can adjust for this chunking, the most relevant being the <code>chunk_size</code> and <code>overlap</code>. We now also support a metadata processing scheme that can improve indexing results for some use cases. We will describe this feature in detail here.</p> <p>Imagine the following scenario: you are indexing a collection of news articles. Each article text starts with a headline and author, and then proceeds with the content. When documents are chunked, they are split evenly according to your configured chunk size. In other words, the first n tokens are read into a text unit, and then the next n, until the end of the content. This means that front matter at the beginning of the document (such as the headline and author in this example) is not copied to each chunk. It only exists in the first chunk. When we later retrieve those chunks for summarization, they may therefore be missing shared information about the source document that should always be provided to the model. We have configuration options to copy repeated content into each text unit to address this issue.</p>"}, {"location": "index/inputs/#input-config", "title": "Input Config", "text": "<p>As described above, when documents are imported you can specify a list of <code>metadata</code> columns to include with each row. This must be configured for the per-chunk copying to work.</p>"}, {"location": "index/inputs/#chunking-config", "title": "Chunking Config", "text": "<p>Next, the <code>chunks</code> block needs to instruct the chunker how to handle this metadata when creating text units. By default, it is ignored. We have two settings to include it:</p> <ul> <li><code>prepend_metadata</code>. This instructs the importer to copy the contents of the <code>metadata</code> column for each row into the start of every single text chunk. This metadata is copied as key: value pairs on new lines.</li> <li><code>chunk_size_includes_metadata</code>: This tells the chunker how to compute the chunk size when metadata is included. By default, we create the text units using your specified <code>chunk_size</code> and then prepend the metadata. This means that the final text unit lengths may be longer than your configured <code>chunk_size</code>, and it will vary based on the length of the metadata for each document. When this setting is <code>True</code>, we will compute the raw text using the remainder after measuring the metadata length so that the resulting text units always comply with your configured <code>chunk_size</code>.</li> </ul>"}, {"location": "index/inputs/#examples", "title": "Examples", "text": "<p>The following are several examples to help illustrate how chunking config and metadate prepending works for each file format. Note that we are using word count here as \"tokens\" for the illustration, but language model tokens are not equivalent to words.</p>"}, {"location": "index/inputs/#text-files", "title": "Text files", "text": "<p>This example uses two individual news article text files.</p> <p>--</p> <p>File: US to lift most federal COVID-19 vaccine mandates.txt</p> <p>Content:</p> <p>WASHINGTON (AP) The Biden administration will end most of the last remaining federal COVID-19 vaccine requirements next week when the national public health emergency for the coronavirus ends, the White House said Monday. Vaccine requirements for federal workers and federal contractors, as well as foreign air travelers to the U.S., will end May 11. The government is also beginning the process of lifting shot requirements for Head Start educators, healthcare workers, and noncitizens at U.S. land borders. The requirements are among the last vestiges of some of the more coercive measures taken by the federal government to promote vaccination as the deadly virus raged, and their end marks the latest display of how President Joe Biden's administration is moving to treat COVID-19 as a routine, endemic illness. \"While I believe that these vaccine mandates had a tremendous beneficial impact, we are now at a point where we think that it makes a lot of sense to pull these requirements down,\" White House COVID-19 coordinator Dr. Ashish Jha told The Associated Press on Monday.</p> <p>--</p> <p>File: NY lawmakers begin debating budget 1 month after due date.txt</p> <p>Content:</p> <p>ALBANY, N.Y. (AP) New York lawmakers began voting Monday on a $229 billion state budget due a month ago that would raise the minimum wage, crack down on illicit pot shops and ban gas stoves and furnaces in new buildings. Negotiations among Gov. Kathy Hochul and her fellow Democrats in control of the Legislature dragged on past the April 1 budget deadline, largely because of disagreements over changes to the bail law and other policy proposals included in the spending plan. Floor debates on some budget bills began Monday. State Senate Majority Leader Andrea Stewart-Cousins said she expected voting to be wrapped up Tuesday for a budget she said contains \"significant wins\" for New Yorkers. \"I would have liked to have done this sooner. I think we would all agree to that,\" Cousins told reporters before voting began. \"This has been a very policy-laden budget and a lot of the policies had to parsed through.\" Hochul was able to push through a change to the bail law that will eliminate the standard that requires judges to prescribe the \"least restrictive\" means to ensure defendants return to court. Hochul said judges needed the extra discretion. Some liberal lawmakers argued that it would undercut the sweeping bail reforms approved in 2019 and result in more people with low incomes and people of color in pretrial detention. Here are some other policy provisions that will be included in the budget, according to state officials. The minimum wage would be raised to $17 in New York City and some of its suburbs and $16 in the rest of the state by 2026. That's up from $15 in the city and $14.20 upstate.</p> <p>--</p> <p>settings.yaml</p> <pre><code>input:\n    file_type: text\n    metadata: [title]\n\nchunks:\n    size: 100\n    overlap: 0\n    prepend_metadata: true\n    chunk_size_includes_metadata: false\n</code></pre> <p>Documents DataFrame</p> id title text creation_date metadata (generated from text) US to lift most federal COVID-19 vaccine mandates.txt (full content of text file) (create date of article txt file) { \"title\": \"US to lift most federal COVID-19 vaccine mandates.txt\" } (generated from text) NY lawmakers begin debating budget 1 month after due date.txt (full content of text file) (create date of article txt file) { \"title\": \"NY lawmakers begin debating budget 1 month after due date.txt\" } <p>Raw Text Chunks</p> content length title: US to lift most federal COVID-19 vaccine mandates.txtWASHINGTON (AP) The Biden administration will end most of the last remaining federal COVID-19 vaccine requirements next week when the national public health emergency for the coronavirus ends, the White House said Monday. Vaccine requirements for federal workers and federal contractors, as well as foreign air travelers to the U.S., will end May 11. The government is also beginning the process of lifting shot requirements for Head Start educators, healthcare workers, and noncitizens at U.S. land borders. The requirements are among the last vestiges of some of the more coercive measures taken by the federal government to promote vaccination as 109 title: US to lift most federal COVID-19 vaccine mandates.txtthe deadly virus raged, and their end marks the latest display of how President Joe Biden's administration is moving to treat COVID-19 as a routine, endemic illness. \"While I believe that these vaccine mandates had a tremendous beneficial impact, we are now at a point where we think that it makes a lot of sense to pull these requirements down,\" White House COVID-19 coordinator Dr. Ashish Jha told The Associated Press on Monday. 82 title: NY lawmakers begin debating budget 1 month after due date.txtALBANY, N.Y. (AP) New York lawmakers began voting Monday on a $229 billion state budget due a month ago that would raise the minimum wage, crack down on illicit pot shops and ban gas stoves and furnaces in new buildings. Negotiations among Gov. Kathy Hochul and her fellow Democrats in control of the Legislature dragged on past the April 1 budget deadline, largely because of disagreements over changes to the bail law and other policy proposals included in the spending plan. Floor debates on some budget bills began Monday. State Senate Majority Leader Andrea Stewart-Cousins said she expected voting to 111 title: NY lawmakers begin debating budget 1 month after due date.txtbe wrapped up Tuesday for a budget she said contains \"significant wins\" for New Yorkers. \"I would have liked to have done this sooner. I think we would all agree to that,\" Cousins told reporters before voting began. \"This has been a very policy-laden budget and a lot of the policies had to parsed through.\" Hochul was able to push through a change to the bail law that will eliminate the standard that requires judges to prescribe the \"least restrictive\" means to ensure defendants return to court. Hochul said judges needed the extra discretion. Some liberal lawmakers argued that it 111 title: NY lawmakers begin debating budget 1 month after due date.txtwould undercut the sweeping bail reforms approved in 2019 and result in more people with low incomes and people of color in pretrial detention. Here are some other policy provisions that will be included in the budget, according to state officials. The minimum wage would be raised to $17 in New York City and some of its suburbs and $16 in the rest of the state by 2026. That's up from $15 in the city and $14.20 upstate. 89 <p>In this example we can see that the two input documents were parsed into five output text chunks. The title (filename) of each document is prepended but not included in the computed chunk size. Also note that the final text chunk for each document is usually smaller than the chunk size because it contains the last tokens.</p>"}, {"location": "index/inputs/#csv-files", "title": "CSV files", "text": "<p>This example uses a single CSV file with the same two articles as rows (note that the text content is not properly escaped for actual CSV use).</p> <p>--</p> <p>File: articles.csv</p> <p>Content</p> <p>headline,article</p> <p>US to lift most federal COVID-19 vaccine mandates,WASHINGTON (AP) The Biden administration will end most of the last remaining federal COVID-19 vaccine requirements next week when the national public health emergency for the coronavirus ends, the White House said Monday. Vaccine requirements for federal workers and federal contractors, as well as foreign air travelers to the U.S., will end May 11. The government is also beginning the process of lifting shot requirements for Head Start educators, healthcare workers, and noncitizens at U.S. land borders. The requirements are among the last vestiges of some of the more coercive measures taken by the federal government to promote vaccination as the deadly virus raged, and their end marks the latest display of how President Joe Biden's administration is moving to treat COVID-19 as a routine, endemic illness. \"While I believe that these vaccine mandates had a tremendous beneficial impact, we are now at a point where we think that it makes a lot of sense to pull these requirements down,\" White House COVID-19 coordinator Dr. Ashish Jha told The Associated Press on Monday.</p> <p>NY lawmakers begin debating budget 1 month after due date,ALBANY, N.Y. (AP) New York lawmakers began voting Monday on a $229 billion state budget due a month ago that would raise the minimum wage, crack down on illicit pot shops and ban gas stoves and furnaces in new buildings. Negotiations among Gov. Kathy Hochul and her fellow Democrats in control of the Legislature dragged on past the April 1 budget deadline, largely because of disagreements over changes to the bail law and other policy proposals included in the spending plan. Floor debates on some budget bills began Monday. State Senate Majority Leader Andrea Stewart-Cousins said she expected voting to be wrapped up Tuesday for a budget she said contains \"significant wins\" for New Yorkers. \"I would have liked to have done this sooner. I think we would all agree to that,\" Cousins told reporters before voting began. \"This has been a very policy-laden budget and a lot of the policies had to parsed through.\" Hochul was able to push through a change to the bail law that will eliminate the standard that requires judges to prescribe the \"least restrictive\" means to ensure defendants return to court. Hochul said judges needed the extra discretion. Some liberal lawmakers argued that it would undercut the sweeping bail reforms approved in 2019 and result in more people with low incomes and people of color in pretrial detention. Here are some other policy provisions that will be included in the budget, according to state officials. The minimum wage would be raised to $17 in New York City and some of its suburbs and $16 in the rest of the state by 2026. That's up from $15 in the city and $14.20 upstate.</p> <p>--</p> <p>settings.yaml</p> <pre><code>input:\n    file_type: csv\n    title_column: headline\n    text_column: article\n    metadata: [headline]\n\nchunks:\n    size: 50\n    overlap: 5\n    prepend_metadata: true\n    chunk_size_includes_metadata: true\n</code></pre> <p>Documents DataFrame</p> id title text creation_date metadata (generated from text) US to lift most federal COVID-19 vaccine mandates (article column content) (create date of articles.csv) { \"headline\": \"US to lift most federal COVID-19 vaccine mandates\" } (generated from text) NY lawmakers begin debating budget 1 month after due date (article column content) (create date of articles.csv) { \"headline\": \"NY lawmakers begin debating budget 1 month after due date\" } <p>Raw Text Chunks</p> content length title: US to lift most federal COVID-19 vaccine mandatesWASHINGTON (AP) The Biden administration will end most of the last remaining federal COVID-19 vaccine requirements next week when the national public health emergency for the coronavirus ends, the White House said Monday. Vaccine requirements for federal workers and federal contractors, 50 title: US to lift most federal COVID-19 vaccine mandatesfederal workers and federal contractors as well as foreign air travelers to the U.S., will end May 11. The government is also beginning the process of lifting shot requirements for Head Start educators, healthcare workers, and noncitizens at U.S. land borders. 50 title: US to lift most federal COVID-19 vaccine mandatesnoncitizens at U.S. land borders. The requirements are among the last vestiges of some of the more coercive measures taken by the federal government to promote vaccination as the deadly virus raged, and their end marks the latest display of how 50 title: US to lift most federal COVID-19 vaccine mandatesthe latest display of how  President Joe Biden's administration is moving to treat COVID-19 as a routine, endemic illness. \"While I believe that these vaccine mandates had a tremendous beneficial impact, we are now at a point where we think that 50 title: US to lift most federal COVID-19 vaccine mandatespoint where we think that it makes a lot of sense to pull these requirements down,\" White House COVID-19 coordinator Dr. Ashish Jha told The Associated Press on Monday. 38 title: NY lawmakers begin debating budget 1 month after due dateALBANY, N.Y. (AP) New York lawmakers began voting Monday on a $229 billion state budget due a month ago that would raise the minimum wage, crack down on illicit pot shops and ban gas stoves and furnaces in new 50 title: NY lawmakers begin debating budget 1 month after due datestoves and furnaces in new buildings. Negotiations among Gov. Kathy Hochul and her fellow Democrats in control of the Legislature dragged on past the April 1 budget deadline, largely because of disagreements over changes to the bail law and 50 title: NY lawmakers begin debating budget 1 month after due dateto the bail law and other policy proposals included in the spending plan. Floor debates on some budget bills began Monday. State Senate Majority Leader Andrea Stewart-Cousins said she expected voting to be wrapped up Tuesday for a budget 50 title: NY lawmakers begin debating budget 1 month after due dateup Tuesday for a budget she said contains \"significant wins\" for New Yorkers. \"I would have liked to have done this sooner. I think we would all agree to that,\" Cousins told reporters before voting began. \"This has been 50 title: NY lawmakers begin debating budget 1 month after due datevoting began. \"This has been a very policy-laden budget and a lot of the policies had to parsed through.\" Hochul was able to push through a change to the bail law that will eliminate the standard that requires judges 50 title: NY lawmakers begin debating budget 1 month after due datethe standard that requires judges to prescribe the \"least restrictive\" means to ensure defendants return to court. Hochul said judges needed the extra discretion. Some liberal lawmakers argued that it would undercut the sweeping bail reforms approved in 2019 50 title: NY lawmakers begin debating budget 1 month after due datebail reforms approved in 2019 and result in more people with low incomes and people of color in pretrial detention. Here are some other policy provisions that will be included in the budget, according to state officials. The minimum 50 title: NY lawmakers begin debating budget 1 month after due dateto state officials. The minimum  wage would be raised to $17 in be raised to $17 in New York City and some of its suburbs and $16 in the rest of the state by 2026. That's up from $15 50 title: NY lawmakers begin debating budget 1 month after due date2026. That's up from $15 in the city and $14.20 upstate. 22 <p>In this example we can see that the two input documents were parsed into fourteen output text chunks. The title (headline) of each document is prepended and included in the computed chunk size, so each chunk matches the configured chunk size (except the last one for each document). We've also configured some overlap in these text chunks, so the last five tokens are shared. Why would you use overlap in your text chunks? Consider that when you are splitting documents based on tokens, it is highly likely that sentences or even related concepts will be split into separate chunks. Each text chunk is processed separately by the language model, so this may result in incomplete \"ideas\" at the boundaries of the chunk. Overlap ensures that these split concepts are fully contained in at least one of the chunks.</p>"}, {"location": "index/inputs/#json-files", "title": "JSON files", "text": "<p>This final example uses a JSON file for each of the same two articles. In this example we'll set the object fields to read, but we will not add metadata to the text chunks.</p> <p>--</p> <p>File: article1.json</p> <p>Content</p> <pre><code>{\n    \"headline\": \"US to lift most federal COVID-19 vaccine mandates\",\n    \"content\": \"WASHINGTON (AP) The Biden administration will end most of the last remaining federal COVID-19 vaccine requirements next week when the national public health emergency for the coronavirus ends, the White House said Monday. Vaccine requirements for federal workers and federal contractors, as well as foreign air travelers to the U.S., will end May 11. The government is also beginning the process of lifting shot requirements for Head Start educators, healthcare workers, and noncitizens at U.S. land borders. The requirements are among the last vestiges of some of the more coercive measures taken by the federal government to promote vaccination as the deadly virus raged, and their end marks the latest display of how President Joe Biden's administration is moving to treat COVID-19 as a routine, endemic illness. \"While I believe that these vaccine mandates had a tremendous beneficial impact, we are now at a point where we think that it makes a lot of sense to pull these requirements down,\" White House COVID-19 coordinator Dr. Ashish Jha told The Associated Press on Monday.\"\n}\n</code></pre> <p>File: article2.json</p> <p>Content</p> <pre><code>{\n    \"headline\": \"NY lawmakers begin debating budget 1 month after due date\",\n    \"content\": \"ALBANY, N.Y. (AP) New York lawmakers began voting Monday on a $229 billion state budget due a month ago that would raise the minimum wage, crack down on illicit pot shops and ban gas stoves and furnaces in new buildings. Negotiations among Gov. Kathy Hochul and her fellow Democrats in control of the Legislature dragged on past the April 1 budget deadline, largely because of disagreements over changes to the bail law and other policy proposals included in the spending plan. Floor debates on some budget bills began Monday. State Senate Majority Leader Andrea Stewart-Cousins said she expected voting to be wrapped up Tuesday for a budget she said contains \"significant wins\" for New Yorkers. \"I would have liked to have done this sooner. I think we would all agree to that,\" Cousins told reporters before voting began. \"This has been a very policy-laden budget and a lot of the policies had to parsed through.\" Hochul was able to push through a change to the bail law that will eliminate the standard that requires judges to prescribe the \"least restrictive\" means to ensure defendants return to court. Hochul said judges needed the extra discretion. Some liberal lawmakers argued that it would undercut the sweeping bail reforms approved in 2019 and result in more people with low incomes and people of color in pretrial detention. Here are some other policy provisions that will be included in the budget, according to state officials. The minimum wage would be raised to $17 in New York City and some of its suburbs and $16 in the rest of the state by 2026. That's up from $15 in the city and $14.20 upstate.\"\n}\n</code></pre> <p>--</p> <p>settings.yaml</p> <pre><code>input:\n    file_type: json\n    title_column: headline\n    text_column: content\n\nchunks:\n    size: 100\n    overlap: 10\n</code></pre> <p>Documents DataFrame</p> id title text creation_date metadata (generated from text) US to lift most federal COVID-19 vaccine mandates (article column content) (create date of article1.json) { } (generated from text) NY lawmakers begin debating budget 1 month after due date (article column content) (create date of article2.json) { } <p>Raw Text Chunks</p> content length WASHINGTON (AP) The Biden administration will end most of the last remaining federal COVID-19 vaccine requirements next week when the national public health emergency for the coronavirus ends, the White House said Monday. Vaccine requirements for federal workers and federal contractors, as well as foreign air travelers to the U.S., will end May 11. The government is also beginning the process of lifting shot requirements for Head Start educators, healthcare workers, and noncitizens at U.S. land borders. The requirements are among the last vestiges of some of the more coercive measures taken by the federal government to promote vaccination as 100 measures taken by the federal government to promote vaccination as  the deadly virus raged, and their end marks the latest display of how President Joe Biden's administration is moving to treat COVID-19 as a routine, endemic illness. \"While I believe that these vaccine mandates had a tremendous beneficial impact, we are now at a point where we think that it makes a lot of sense to pull these requirements down,\" White House COVID-19 coordinator Dr. Ashish Jha told The Associated Press on Monday. 83 ALBANY, N.Y. (AP) New York lawmakers began voting Monday on a $229 billion state budget due a month ago that would raise the minimum wage, crack down on illicit pot shops and ban gas stoves and furnaces in new buildings. Negotiations among Gov. Kathy Hochul and her fellow Democrats in control of the Legislature dragged on past the April 1 budget deadline, largely because of disagreements over changes to the bail law and other policy proposals included in the spending plan. Floor debates on some budget bills began Monday. State Senate Majority Leader Andrea Stewart-Cousins said she expected voting to 100 Senate Majority Leader Andrea Stewart-Cousins said she expected voting to be wrapped up Tuesday for a budget she said contains \"significant wins\" for New Yorkers. \"I would have liked to have done this sooner. I think we would all agree to that,\" Cousins told reporters before voting began. \"This has been a very policy-laden budget and a lot of the policies had to parsed through.\" Hochul was able to push through a change to the bail law that will eliminate the standard that requires judges to prescribe the \"least restrictive\" means to ensure defendants return to court. Hochul said judges 100 means to ensure defendants return to court. Hochul said judges needed the extra discretion. Some liberal lawmakers argued that it would undercut the sweeping bail reforms approved in 2019 and result in more people with low incomes and people of color in pretrial detention. Here are some other policy provisions that will be included in the budget, according to state officials. The minimum wage would be raised to $17 in New York City and some of its suburbs and $16 in the rest of the state by 2026. That's up from $15 in the city and $14.20 upstate. 98 <p>In this example the two input documents were parsed into five output text chunks. There is no metadata prepended, so each chunk matches the configured chunk size (except the last one for each document). We've also configured some overlap in these text chunks, so the last ten tokens are shared.</p>"}, {"location": "index/methods/", "title": "Indexing Methods", "text": "<p>GraphRAG is a platform for our research into RAG indexing methods that produce optimal context window content for language models. We have a standard indexing pipeline that uses a language model to extract the graph that our memory model is based upon. We may introduce additional indexing methods from time to time. This page documents those options.</p>"}, {"location": "index/methods/#standard-graphrag", "title": "Standard GraphRAG", "text": "<p>This is the method described in the original blog post. Standard uses a language model for all reasoning tasks:</p> <ul> <li>entity extraction: LLM is prompted to extract named entities and provide a description from each text unit.</li> <li>relationship extraction: LLM is prompted to describe the relationship between each pair of entities in each text unit.</li> <li>entity summarization: LLM is prompted to combine the descriptions for every instance of an entity found across the text units into a single summary.</li> <li>relationship summarization: LLM is prompted to combine the descriptions for every instance of a relationship found across the text units into a single summary.</li> <li>claim extraction (optional): LLM is prompted to extract and describe claims from each text unit.</li> <li>community report generation: entity and relationship descriptions (and optionally claims) for each community are collected and used to prompt the LLM to generate a summary report.</li> </ul> <p><code>graphrag index --method standard</code>. This is the default method, so the method param can actual be omitted.</p>"}, {"location": "index/methods/#fastgraphrag", "title": "FastGraphRAG", "text": "<p>FastGraphRAG is a method that substitutes some of the language model reasoning for traditional natural language processing (NLP) methods. This is a hybrid technique that we developed as a faster and cheaper indexing alternative:</p> <ul> <li>entity extraction: entities are noun phrases extracted using NLP libraries such as NLTK and spaCy. There is no description; the source text unit is used for this.</li> <li>relationship extraction: relationships are defined as text unit co-occurrence between entity pairs. There is no description.</li> <li>entity summarization: not necessary.</li> <li>relationship summarization: not necessary.</li> <li>claim extraction (optional): unused.</li> <li>community report generation: The direct text unit content containing each entity noun phrase is collected and used to prompt the LLM to generate a summary report.</li> </ul> <p><code>graphrag index --method fast</code></p> <p>FastGraphRAG has a handful of NLP options built in. By default we use NLTK + regular expressions for the noun phrase extraction, which is very fast but primarily suitable for English. We have built in two additional methods using spaCy: semantic parsing and CFG. We use the <code>en_core_web_md</code> model by default for spaCy, but note that you can reference any supported model that you have installed. </p> <p>Note that we also generally configure the text chunking to produce much smaller chunks (50-100 tokens). This results in a better co-occurrence graph.</p> <p>\u26a0\ufe0f Note on SpaCy models:</p> <p>This package requires SpaCy models to function correctly. If the required model is not installed, the package will automatically download and install it the first time it is used.</p> <p>You can install it manually by running <code>python -m spacy download &lt;model_name&gt;</code>, for example <code>python -m spacy download en_core_web_md</code>.</p>"}, {"location": "index/methods/#choosing-a-method", "title": "Choosing a Method", "text": "<p>Standard GraphRAG provides a rich description of real-world entities and relationships, but is more expensive that FastGraphRAG. We estimate graph extraction to constitute roughly 75% of indexing cost. FastGraphRAG is therefore much cheaper, but the tradeoff is that the extracted graph is less directly relevant for use outside of GraphRAG, and the graph tends to be quite a bit noisier. If high fidelity entities and graph exploration are important to your use case, we recommend staying with traditional GraphRAG. If your use case is primarily aimed at summary questions using global search, FastGraphRAG provides high quality summarization at much less LLM cost.</p>"}, {"location": "index/outputs/", "title": "Outputs", "text": "<p>The default pipeline produces a series of output tables that align with the conceptual knowledge model. This page describes the detailed output table schemas. By default we write these tables out as parquet files on disk.</p>"}, {"location": "index/outputs/#shared-fields", "title": "Shared fields", "text": "<p>All tables have two identifier fields:</p> name type description id str Generated UUID, assuring global uniqueness human_readable_id int This is an incremented short ID created per-run. For example, we use this short ID with generated summaries that print citations so they are easy to cross-reference visually."}, {"location": "index/outputs/#communities", "title": "communities", "text": "<p>This is a list of the final communities generated by Leiden. Communities are strictly hierarchical, subdividing into children as the cluster affinity is narrowed.</p> name type description community int Leiden-generated cluster ID for the community. Note that these increment with depth, so they are unique through all levels of the community hierarchy. For this table, human_readable_id is a copy of the community ID rather than a plain increment. parent int Parent community ID. children int[] List of child community IDs. level int Depth of the community in the hierarchy. title str Friendly name of the community. entity_ids str[] List of entities that are members of the community. relationship_ids str[] List of relationships that are wholly within the community (source and target are both in the community). text_unit_ids str[] List of text units represented within the community. period str Date of ingest, used for incremental update merges. ISO8601 size int Size of the community (entity count), used for incremental update merges."}, {"location": "index/outputs/#community_reports", "title": "community_reports", "text": "<p>This is the list of summarized reports for each community.</p> name type description community int Short ID of the community this report applies to. parent int Parent community ID. children int[] List of child community IDs. level int Level of the community this report applies to. title str LM-generated title for the report. summary str LM-generated summary of the report. full_content str LM-generated full report. rank float LM-derived relevance ranking of the report based on member entity salience rating_explanation str LM-derived explanation of the rank. findings dict LM-derived list of the top 5-10 insights from the community. Contains <code>summary</code> and <code>explanation</code> values. full_content_json json Full JSON output as returned by the LM. Most fields are extracted into columns, but this JSON is sent for query summarization so we leave it to allow for prompt tuning to add fields/content by end users. period str Date of ingest, used for incremental update merges. ISO8601 size int Size of the community (entity count), used for incremental update merges."}, {"location": "index/outputs/#covariates", "title": "covariates", "text": "<p>(Optional) If claim extraction is turned on, this is a list of the extracted covariates. Note that claims are typically oriented around identifying malicious behavior such as fraud, so they are not useful for all datasets.</p> name type description covariate_type str This is always \"claim\" with our default covariates. type str Nature of the claim type. description str LM-generated description of the behavior. subject_id str Name of the source entity (that is performing the claimed behavior). object_id str Name of the target entity (that the claimed behavior is performed on). status str LM-derived assessment of the correctness of the claim. One of [TRUE, FALSE, SUSPECTED] start_date str LM-derived start of the claimed activity. ISO8601 end_date str LM-derived end of the claimed activity. ISO8601 source_text str Short string of text containing the claimed behavior. text_unit_id str ID of the text unit the claim text was extracted from."}, {"location": "index/outputs/#documents", "title": "documents", "text": "<p>List of document content after import.</p> name type description title str Filename, unless otherwise configured during CSV import. text str Full text of the document. text_unit_ids str[] List of text units (chunks) that were parsed from the document. metadata dict If specified during CSV import, this is a dict of metadata for the document."}, {"location": "index/outputs/#entities", "title": "entities", "text": "<p>List of all entities found in the data by the LM.</p> name type description title str Name of the entity. type str Type of the entity. By default this will be \"organization\", \"person\", \"geo\", or \"event\" unless configured differently or auto-tuning is used. description str Textual description of the entity. Entities may be found in many text units, so this is an LM-derived summary of all descriptions. text_unit_ids str[] List of the text units containing the entity. frequency int Count of text units the entity was found within. degree int Node degree (connectedness) in the graph. x float X position of the node for visual layouts. If graph embeddings and UMAP are not turned on, this will be 0. y float Y position of the node for visual layouts. If graph embeddings and UMAP are not turned on, this will be 0."}, {"location": "index/outputs/#relationships", "title": "relationships", "text": "<p>List of all entity-to-entity relationships found in the data by the LM. This is also the edge list for the graph.</p> name type description source str Name of the source entity. target str Name of the target entity. description str LM-derived description of the relationship. Also see note for entity descriptions. weight float Weight of the edge in the graph. This is summed from an LM-derived \"strength\" measure for each relationship instance. combined_degree int Sum of source and target node degrees. text_unit_ids str[] List of text units the relationship was found within."}, {"location": "index/outputs/#text_units", "title": "text_units", "text": "<p>List of all text chunks parsed from the input documents.</p> name type description text str Raw full text of the chunk. n_tokens int Number of tokens in the chunk. This should normally match the <code>chunk_size</code> config parameter, except for the last chunk which is often shorter. document_ids str[] List of document IDs the chunk came from. This is normally only 1 due to our default groupby, but for very short text documents (e.g., microblogs) it can be configured so text units span multiple documents. entity_ids str[] List of entities found in the text unit. relationships_ids str[] List of relationships found in the text unit. covariate_ids str[] Optional list of covariates found in the text unit."}, {"location": "index/overview/", "title": "GraphRAG Indexing \ud83e\udd16", "text": "<p>The GraphRAG indexing package is a data pipeline and transformation suite that is designed to extract meaningful, structured data from unstructured text using LLMs.</p> <p>Indexing Pipelines are configurable. They are composed of workflows, standard and custom steps, prompt templates, and input/output adapters. Our standard pipeline is designed to:</p> <ul> <li>extract entities, relationships and claims from raw text</li> <li>perform community detection in entities</li> <li>generate community summaries and reports at multiple levels of granularity</li> <li>embed entities into a graph vector space</li> <li>embed text chunks into a textual vector space</li> </ul> <p>The outputs of the pipeline are stored as Parquet tables by default, and embeddings are written to your configured vector store.</p>"}, {"location": "index/overview/#getting-started", "title": "Getting Started", "text": ""}, {"location": "index/overview/#requirements", "title": "Requirements", "text": "<p>See the requirements section in Get Started for details on setting up a development environment.</p> <p>To configure GraphRAG, see the configuration documentation. After you have a config file you can run the pipeline using the CLI or the Python API.</p>"}, {"location": "index/overview/#usage", "title": "Usage", "text": ""}, {"location": "index/overview/#cli", "title": "CLI", "text": "<pre><code>uv run poe index --root &lt;data_root&gt; # default config mode\n</code></pre>"}, {"location": "index/overview/#python-api", "title": "Python API", "text": "<p>Please see the indexing API python file for the recommended method to call directly from Python code.</p>"}, {"location": "index/overview/#further-reading", "title": "Further Reading", "text": "<ul> <li>To start developing within the GraphRAG project, see getting started</li> <li>To understand the underlying concepts and execution model of the indexing library, see the architecture documentation</li> <li>To read more about configuring the indexing engine, see the configuration documentation</li> </ul>"}, {"location": "prompt_tuning/auto_prompt_tuning/", "title": "Auto Prompt Tuning \u2699\ufe0f", "text": "<p>GraphRAG provides the ability to create domain adapted prompts for the generation of the knowledge graph. This step is optional, though it is highly encouraged to run it as it will yield better results when executing an Index Run.</p> <p>These are generated by loading the inputs, splitting them into chunks (text units) and then running a series of LLM invocations and template substitutions to generate the final prompts. We suggest using the default values provided by the script, but in this page you'll find the detail of each in case you want to further explore and tweak the prompt tuning algorithm.</p> <p> </p> <p> Figure 1: Auto Tuning Conceptual Diagram. </p>"}, {"location": "prompt_tuning/auto_prompt_tuning/#prerequisites", "title": "Prerequisites", "text": "<p>Before running auto tuning, ensure you have already initialized your workspace with the <code>graphrag init</code> command. This will create the necessary configuration files and the default prompts. Refer to the Init Documentation for more information about the initialization process.</p>"}, {"location": "prompt_tuning/auto_prompt_tuning/#usage", "title": "Usage", "text": "<p>You can run the main script from the command line with various options:</p> <pre><code>graphrag prompt-tune [--root ROOT] [--config CONFIG] [--domain DOMAIN]  [--selection-method METHOD] [--limit LIMIT] [--language LANGUAGE] \\\n[--max-tokens MAX_TOKENS] [--chunk-size CHUNK_SIZE] [--n-subset-max N_SUBSET_MAX] [--k K] \\\n[--min-examples-required MIN_EXAMPLES_REQUIRED] [--discover-entity-types] [--output OUTPUT]\n</code></pre>"}, {"location": "prompt_tuning/auto_prompt_tuning/#command-line-options", "title": "Command-Line Options", "text": "<ul> <li> <p><code>--config</code> (required): The path to the configuration file. This is required to load the data and model settings.</p> </li> <li> <p><code>--root</code> (optional): The data project root directory, including the config files (YML, JSON, or .env). Defaults to the current directory.</p> </li> <li> <p><code>--domain</code> (optional): The domain related to your input data, such as 'space science', 'microbiology', or 'environmental news'. If left empty, the domain will be inferred from the input data.</p> </li> <li> <p><code>--selection-method</code> (optional): The method to select documents. Options are all, random, auto or top. Default is random.</p> </li> <li> <p><code>--limit</code> (optional): The limit of text units to load when using random or top selection. Default is 15.</p> </li> <li> <p><code>--language</code> (optional): The language to use for input processing. If it is different from the inputs' language, the LLM will translate. Default is \"\" meaning it will be automatically detected from the inputs.</p> </li> <li> <p><code>--max-tokens</code> (optional): Maximum token count for prompt generation. Default is 2000.</p> </li> <li> <p><code>--chunk-size</code> (optional): The size in tokens to use for generating text units from input documents. Default is 200.</p> </li> <li> <p><code>--n-subset-max</code> (optional): The number of text chunks to embed when using auto selection method. Default is 300.</p> </li> <li> <p><code>--k</code> (optional): The number of documents to select when using auto selection method. Default is 15.</p> </li> <li> <p><code>--min-examples-required</code> (optional): The minimum number of examples required for entity extraction prompts. Default is 2.</p> </li> <li> <p><code>--discover-entity-types</code> (optional): Allow the LLM to discover and extract entities automatically. We recommend using this when your data covers a lot of topics or it is highly randomized.</p> </li> <li> <p><code>--output</code> (optional): The folder to save the generated prompts. Default is \"prompts\".</p> </li> </ul>"}, {"location": "prompt_tuning/auto_prompt_tuning/#example-usage", "title": "Example Usage", "text": "<pre><code>python -m graphrag prompt-tune --root /path/to/project --config /path/to/settings.yaml --domain \"environmental news\" \\\n--selection-method random --limit 10 --language English --max-tokens 2048 --chunk-size 256 --min-examples-required 3 \\\n--no-discover-entity-types --output /path/to/output\n</code></pre> <p>or, with minimal configuration (suggested):</p> <pre><code>python -m graphrag prompt-tune --root /path/to/project --config /path/to/settings.yaml --no-discover-entity-types\n</code></pre>"}, {"location": "prompt_tuning/auto_prompt_tuning/#document-selection-methods", "title": "Document Selection Methods", "text": "<p>The auto tuning feature ingests the input data and then divides it into text units the size of the chunk size parameter. After that, it uses one of the following selection methods to pick a sample to work with for prompt generation:</p> <ul> <li><code>random</code>: Select text units randomly. This is the default and recommended option.</li> <li><code>top</code>: Select the head n text units.</li> <li><code>all</code>: Use all text units for the generation. Use only with small datasets; this option is not usually recommended.</li> <li><code>auto</code>: Embed text units in a lower-dimensional space and select the k nearest neighbors to the centroid. This is useful when you have a large dataset and want to select a representative sample.</li> </ul>"}, {"location": "prompt_tuning/auto_prompt_tuning/#modify-env-vars", "title": "Modify Env Vars", "text": "<p>After running auto tuning, you should modify the following environment variables (or config variables) to pick up the new prompts on your index run. Note: Please make sure to update the correct path to the generated prompts, in this example we are using the default \"prompts\" path.</p> <ul> <li> <p><code>GRAPHRAG_ENTITY_EXTRACTION_PROMPT_FILE</code> = \"prompts/entity_extraction.txt\"</p> </li> <li> <p><code>GRAPHRAG_COMMUNITY_REPORT_PROMPT_FILE</code> = \"prompts/community_report.txt\"</p> </li> <li> <p><code>GRAPHRAG_SUMMARIZE_DESCRIPTIONS_PROMPT_FILE</code> = \"prompts/summarize_descriptions.txt\"</p> </li> </ul> <p>or in your yaml config file:</p> <pre><code>entity_extraction:\n  prompt: \"prompts/entity_extraction.txt\"\n\nsummarize_descriptions:\n  prompt: \"prompts/summarize_descriptions.txt\"\n\ncommunity_reports:\n  prompt: \"prompts/community_report.txt\"\n</code></pre>"}, {"location": "prompt_tuning/manual_prompt_tuning/", "title": "Manual Prompt Tuning \u2699\ufe0f", "text": "<p>The GraphRAG indexer, by default, will run with a handful of prompts that are designed to work well in the broad context of knowledge discovery. However, it is quite common to want to tune the prompts to better suit your specific use case. We provide a means for you to do this by allowing you to specify a custom prompt file, which will each use a series of token-replacements internally.</p> <p>Each of these prompts may be overridden by writing a custom prompt file in plaintext. We use token-replacements in the form of <code>{token_name}</code>, and the descriptions for the available tokens can be found below.</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#indexing-prompts", "title": "Indexing Prompts", "text": ""}, {"location": "prompt_tuning/manual_prompt_tuning/#entityrelationship-extraction", "title": "Entity/Relationship Extraction", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens", "title": "Tokens", "text": "<ul> <li>{input_text} - The input text to be processed.</li> <li>{entity_types} - A list of entity types</li> <li>{tuple_delimiter} - A delimiter for separating values within a tuple. A single tuple is used to represent an individual entity or relationship.</li> <li>{record_delimiter} - A delimiter for separating tuple instances.</li> <li>{completion_delimiter} - An indicator for when generation is complete.</li> </ul>"}, {"location": "prompt_tuning/manual_prompt_tuning/#summarize-entityrelationship-descriptions", "title": "Summarize Entity/Relationship Descriptions", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens_1", "title": "Tokens", "text": "<ul> <li>{entity_name} - The name of the entity or the source/target pair of the relationship.</li> <li>{description_list} - A list of descriptions for the entity or relationship.</li> </ul>"}, {"location": "prompt_tuning/manual_prompt_tuning/#claim-extraction", "title": "Claim Extraction", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens_2", "title": "Tokens", "text": "<ul> <li>{input_text} - The input text to be processed.</li> <li>{tuple_delimiter} - A delimiter for separating values within a tuple. A single tuple is used to represent an individual entity or relationship.</li> <li>{record_delimiter} - A delimiter for separating tuple instances.</li> <li>{completion_delimiter} - An indicator for when generation is complete.</li> <li>{entity_specs} - A list of entity types.</li> <li>{claim_description} - Description of what claims should look like. Default is: <code>\"Any claims or facts that could be relevant to information discovery.\"</code></li> </ul> <p>See the configuration documentation for details on how to change this.</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#generate-community-reports", "title": "Generate Community Reports", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens_3", "title": "Tokens", "text": "<ul> <li>{input_text} - The input text to generate the report with. This will contain tables of entities and relationships.</li> </ul>"}, {"location": "prompt_tuning/manual_prompt_tuning/#query-prompts", "title": "Query Prompts", "text": ""}, {"location": "prompt_tuning/manual_prompt_tuning/#local-search", "title": "Local Search", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens_4", "title": "Tokens", "text": "<ul> <li>{response_type} - Describe how the response should look. We default to \"multiple paragraphs\".</li> <li>{context_data} - The data tables from GraphRAG's index.</li> </ul>"}, {"location": "prompt_tuning/manual_prompt_tuning/#global-search", "title": "Global Search", "text": "<p>Mapper Prompt Source</p> <p>Reducer Prompt Source</p> <p>Knowledge Prompt Source</p> <p>Global search uses a map/reduce approach to summarization. You can tune these prompts independently. This search also includes the ability to adjust the use of general knowledge from the model's training.</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens_5", "title": "Tokens", "text": "<ul> <li>{response_type} - Describe how the response should look (reducer only). We default to \"multiple paragraphs\".</li> <li>{context_data} - The data tables from GraphRAG's index.</li> </ul>"}, {"location": "prompt_tuning/manual_prompt_tuning/#drift-search", "title": "Drift Search", "text": "<p>Prompt Source</p>"}, {"location": "prompt_tuning/manual_prompt_tuning/#tokens_6", "title": "Tokens", "text": "<ul> <li>{response_type} - Describe how the response should look. We default to \"multiple paragraphs\".</li> <li>{context_data} - The data tables from GraphRAG's index.</li> <li>{community_reports} - The most relevant community reports to include in the summarization.</li> <li>{query} - The query text as injected into the context.</li> </ul>"}, {"location": "prompt_tuning/overview/", "title": "Prompt Tuning \u2699\ufe0f", "text": "<p>This page provides an overview of the prompt tuning options available for the GraphRAG indexing engine.</p>"}, {"location": "prompt_tuning/overview/#default-prompts", "title": "Default Prompts", "text": "<p>The default prompts are the simplest way to get started with the GraphRAG system. It is designed to work out-of-the-box with minimal configuration. More details about each of the default prompts for indexing and query can be found on the manual tuning page.</p>"}, {"location": "prompt_tuning/overview/#auto-tuning", "title": "Auto Tuning", "text": "<p>Auto Tuning leverages your input data and LLM interactions to create domain adapted prompts for the generation of the knowledge graph. It is highly encouraged to run it as it will yield better results when executing an Index Run. For more details about how to use it, please refer to the Auto Tuning documentation.</p>"}, {"location": "prompt_tuning/overview/#manual-tuning", "title": "Manual Tuning", "text": "<p>Manual tuning is an advanced use-case. Most users will want to use the Auto Tuning feature instead. Details about how to use manual configuration are available in the manual tuning documentation.</p>"}, {"location": "query/drift_search/", "title": "DRIFT Search \ud83d\udd0e", "text": ""}, {"location": "query/drift_search/#combining-local-and-global-search", "title": "Combining Local and Global Search", "text": "<p>GraphRAG is a technique that uses large language models (LLMs) to create knowledge graphs and summaries from unstructured text documents and leverages them to improve retrieval-augmented generation (RAG) operations on private datasets. It offers comprehensive global overviews of large, private troves of unstructured text documents while also enabling exploration of detailed, localized information. By using LLMs to create comprehensive knowledge graphs that connect and describe entities and relationships contained in those documents, GraphRAG leverages semantic structuring of the data to generate responses to a wide variety of complex user queries.</p> <p>DRIFT search (Dynamic Reasoning and Inference with Flexible Traversal) builds upon Microsoft\u2019s GraphRAG technique, combining characteristics of both global and local search to generate detailed responses in a method that balances computational costs with quality outcomes using our drift search method.</p>"}, {"location": "query/drift_search/#methodology", "title": "Methodology", "text": "<p> Figure 1. An entire DRIFT search hierarchy highlighting the three core phases of the DRIFT search process. A (Primer): DRIFT compares the user\u2019s query with the top K most semantically relevant community reports, generating a broad initial answer and follow-up questions to steer further exploration. B (Follow-Up): DRIFT uses local search to refine queries, producing additional intermediate answers and follow-up questions that enhance specificity, guiding the engine towards context-rich information. A glyph on each node in the diagram shows the confidence the algorithm has to continue the query expansion step.  C (Output Hierarchy): The final output is a hierarchical structure of questions and answers ranked by relevance, reflecting a balanced mix of global insights and local refinements, making the results adaptable and comprehensive.</p> <p>DRIFT Search introduces a new approach to local search queries by including community information in the search process. This greatly expands the breadth of the query\u2019s starting point and leads to retrieval and usage of a far higher variety of facts in the final answer. This addition expands the GraphRAG query engine by providing a more comprehensive option for local search, which uses community insights to refine a query into detailed follow-up questions.</p>"}, {"location": "query/drift_search/#configuration", "title": "Configuration", "text": "<p>Below are the key parameters of the DRIFTSearch class:</p> <ul> <li><code>llm</code>: OpenAI model object to be used for response generation</li> <li><code>context_builder</code>: context builder object to be used for preparing context data from community reports and query information</li> <li><code>config</code>: model to define the DRIFT Search hyperparameters. DRIFT Config model</li> <li><code>token_encoder</code>: token encoder for tracking the budget for the algorithm.</li> <li><code>query_state</code>: a state object as defined in Query State that allows to track execution of a DRIFT Search instance, alongside follow ups and DRIFT actions.</li> </ul>"}, {"location": "query/drift_search/#how-to-use", "title": "How to Use", "text": "<p>An example of a drift search scenario can be found in the following notebook.</p>"}, {"location": "query/drift_search/#learn-more", "title": "Learn More", "text": "<p>For a more in-depth look at the DRIFT search method, please refer to our DRIFT Search blog post</p>"}, {"location": "query/global_search/", "title": "Global Search \ud83d\udd0e", "text": ""}, {"location": "query/global_search/#whole-dataset-reasoning", "title": "Whole Dataset Reasoning", "text": "<p>Baseline RAG struggles with queries that require aggregation of information across the dataset to compose an answer. Queries such as \u201cWhat are the top 5 themes in the data?\u201d perform terribly because baseline RAG relies on a vector search of semantically similar text content within the dataset. There is nothing in the query to direct it to the correct information.</p> <p>However, with GraphRAG we can answer such questions, because the structure of the LLM-generated knowledge graph tells us about the structure (and thus themes) of the dataset as a whole. This allows the private dataset to be organized into meaningful semantic clusters that are pre-summarized. Using our global search method, the LLM uses these clusters to summarize these themes when responding to a user query.</p>"}, {"location": "query/global_search/#methodology", "title": "Methodology", "text": "<pre><code>---\ntitle: Global Search Dataflow\n---\n%%{ init: { 'flowchart': { 'curve': 'step' } } }%%\nflowchart LR\n\n    uq[User Query] --- .1\n    ch1[Conversation History] --- .1\n\n    subgraph RIR\n        direction TB\n        ri1[Rated Intermediate&lt;br/&gt;Response 1]~~~ri2[Rated Intermediate&lt;br/&gt;Response 2] -.\"{1..N}\".-rin[Rated Intermediate&lt;br/&gt;Response N]\n    end\n\n    .1--Shuffled Community&lt;br/&gt;Report Batch 1--&gt;RIR\n    .1--Shuffled Community&lt;br/&gt;Report Batch 2--&gt;RIR---.2\n    .1--Shuffled Community&lt;br/&gt;Report Batch N--&gt;RIR\n\n    .2--Ranking +&lt;br/&gt;Filtering--&gt;agr[Aggregated Intermediate&lt;br/&gt;Responses]--&gt;res[Response]\n\n\n\n     classDef green fill:#26B653,stroke:#333,stroke-width:2px,color:#fff;\n     classDef turquoise fill:#19CCD3,stroke:#333,stroke-width:2px,color:#fff;\n     classDef rose fill:#DD8694,stroke:#333,stroke-width:2px,color:#fff;\n     classDef orange fill:#F19914,stroke:#333,stroke-width:2px,color:#fff;\n     classDef purple fill:#B356CD,stroke:#333,stroke-width:2px,color:#fff;\n     classDef invisible fill:#fff,stroke:#fff,stroke-width:0px,color:#fff, width:0px;\n     class uq,ch1 turquoise;\n     class ri1,ri2,rin rose;\n     class agr orange;\n     class res purple;\n     class .1,.2 invisible;\n</code></pre> <p>Given a user query and, optionally, the conversation history, the global search method uses a collection of LLM-generated community reports from a specified level of the graph's community hierarchy as context data to generate response in a map-reduce manner. At the <code>map</code> step, community reports are segmented into text chunks of pre-defined size. Each text chunk is then used to produce an intermediate response containing a list of point, each of which is accompanied by a numerical rating indicating the importance of the point. At the <code>reduce</code> step, a filtered set of the most important points from the intermediate responses are aggregated and used as the context to generate the final response. </p> <p>The quality of the global search\u2019s response can be heavily influenced by the level of the community hierarchy chosen for sourcing community reports. Lower hierarchy levels, with their detailed reports, tend to yield more thorough responses, but may also increase the time and LLM resources needed to generate the final response due to the volume of reports.</p>"}, {"location": "query/global_search/#configuration", "title": "Configuration", "text": "<p>Below are the key parameters of the GlobalSearch class:</p> <ul> <li><code>llm</code>: OpenAI model object to be used for response generation</li> <li><code>context_builder</code>: context builder object to be used for preparing context data from community reports</li> <li><code>map_system_prompt</code>: prompt template used in the <code>map</code> stage. Default template can be found at map_system_prompt</li> <li><code>reduce_system_prompt</code>: prompt template used in the <code>reduce</code> stage, default template can be found at reduce_system_prompt</li> <li><code>response_type</code>: free-form text describing the desired response type and format (e.g., <code>Multiple Paragraphs</code>, <code>Multi-Page Report</code>)</li> <li><code>allow_general_knowledge</code>: setting this to True will include additional instructions to the <code>reduce_system_prompt</code> to prompt the LLM to incorporate relevant real-world knowledge outside of the dataset. Note that this may increase hallucinations, but can be useful for certain scenarios. Default is False *<code>general_knowledge_inclusion_prompt</code>: instruction to add to the <code>reduce_system_prompt</code> if <code>allow_general_knowledge</code> is enabled. Default instruction can be found at general_knowledge_instruction</li> <li><code>max_data_tokens</code>: token budget for the context data</li> <li><code>map_llm_params</code>: a dictionary of additional parameters (e.g., temperature, max_tokens) to be passed to the LLM call at the <code>map</code> stage</li> <li><code>reduce_llm_params</code>: a dictionary of additional parameters (e.g., temperature, max_tokens) to passed to the LLM call at the <code>reduce</code> stage</li> <li><code>context_builder_params</code>: a dictionary of additional parameters to be passed to the <code>context_builder</code> object when building context window for the <code>map</code> stage.</li> <li><code>concurrent_coroutines</code>: controls the degree of parallelism in the <code>map</code> stage.</li> <li><code>callbacks</code>: optional callback functions, can be used to provide custom event handlers for LLM's completion streaming events</li> </ul>"}, {"location": "query/global_search/#how-to-use", "title": "How to Use", "text": "<p>An example of a global search scenario can be found in the following notebook.</p>"}, {"location": "query/local_search/", "title": "Local Search \ud83d\udd0e", "text": ""}, {"location": "query/local_search/#entity-based-reasoning", "title": "Entity-based Reasoning", "text": "<p>The local search method combines structured data from the knowledge graph with unstructured data from the input documents to augment the LLM context with relevant entity information at query time. It is well-suited for answering questions that require an understanding of specific entities mentioned in the input documents (e.g., \u201cWhat are the healing properties of chamomile?\u201d).</p>"}, {"location": "query/local_search/#methodology", "title": "Methodology", "text": "<pre><code>---\ntitle: Local Search Dataflow\n---\n%%{ init: { 'flowchart': { 'curve': 'step' } } }%%\nflowchart LR\n\n    uq[User Query] ---.1\n    ch1[Conversation&lt;br/&gt;History]---.1\n\n    .1--Entity&lt;br/&gt;Description&lt;br/&gt;Embedding--&gt; ee[Extracted Entities]\n\n    ee[Extracted Entities] ---.2--Entity-Text&lt;br/&gt;Unit Mapping--&gt; ctu[Candidate&lt;br/&gt;Text Units]--Ranking + &lt;br/&gt;Filtering --&gt;ptu[Prioritized&lt;br/&gt;Text Units]---.3\n    .2--Entity-Report&lt;br/&gt;Mapping--&gt; ccr[Candidate&lt;br/&gt;Community Reports]--Ranking + &lt;br/&gt;Filtering --&gt;pcr[Prioritized&lt;br/&gt;Community Reports]---.3\n    .2--Entity-Entity&lt;br/&gt;Relationships--&gt; ce[Candidate&lt;br/&gt;Entities]--Ranking + &lt;br/&gt;Filtering --&gt;pe[Prioritized&lt;br/&gt;Entities]---.3\n    .2--Entity-Entity&lt;br/&gt;Relationships--&gt; cr[Candidate&lt;br/&gt;Relationships]--Ranking + &lt;br/&gt;Filtering --&gt;pr[Prioritized&lt;br/&gt;Relationships]---.3\n    .2--Entity-Covariate&lt;br/&gt;Mappings--&gt; cc[Candidate&lt;br/&gt;Covariates]--Ranking + &lt;br/&gt;Filtering --&gt;pc[Prioritized&lt;br/&gt;Covariates]---.3\n    ch1 --&gt;ch2[Conversation History]---.3\n    .3--&gt;res[Response]\n\n     classDef green fill:#26B653,stroke:#333,stroke-width:2px,color:#fff;\n     classDef turquoise fill:#19CCD3,stroke:#333,stroke-width:2px,color:#fff;\n     classDef rose fill:#DD8694,stroke:#333,stroke-width:2px,color:#fff;\n     classDef orange fill:#F19914,stroke:#333,stroke-width:2px,color:#fff;\n     classDef purple fill:#B356CD,stroke:#333,stroke-width:2px,color:#fff;\n     classDef invisible fill:#fff,stroke:#fff,stroke-width:0px,color:#fff, width:0px;\n     class uq,ch1 turquoise\n     class ee green\n     class ctu,ccr,ce,cr,cc rose\n     class ptu,pcr,pe,pr,pc,ch2 orange\n     class res purple\n     class .1,.2,.3 invisible\n\n</code></pre> <p>Given a user query and, optionally, the conversation history, the local search method identifies a set of entities from the knowledge graph that are semantically-related to the user input. These entities serve as access points into the knowledge graph, enabling the extraction of further relevant details such as connected entities, relationships, entity covariates, and community reports. Additionally, it also extracts relevant text chunks from the raw input documents that are associated with the identified entities. These candidate data sources are then prioritized and filtered to fit within a single context window of pre-defined size, which is used to generate a response to the user query.</p>"}, {"location": "query/local_search/#configuration", "title": "Configuration", "text": "<p>Below are the key parameters of the LocalSearch class:</p> <ul> <li><code>llm</code>: OpenAI model object to be used for response generation</li> <li><code>context_builder</code>: context builder object to be used for preparing context data from collections of knowledge model objects</li> <li><code>system_prompt</code>: prompt template used to generate the search response. Default template can be found at system_prompt</li> <li><code>response_type</code>: free-form text describing the desired response type and format (e.g., <code>Multiple Paragraphs</code>, <code>Multi-Page Report</code>)</li> <li><code>llm_params</code>: a dictionary of additional parameters (e.g., temperature, max_tokens) to be passed to the LLM call</li> <li><code>context_builder_params</code>: a dictionary of additional parameters to be passed to the <code>context_builder</code> object when building context for the search prompt</li> <li><code>callbacks</code>: optional callback functions, can be used to provide custom event handlers for LLM's completion streaming events</li> </ul>"}, {"location": "query/local_search/#how-to-use", "title": "How to Use", "text": "<p>An example of a local search scenario can be found in the following notebook.</p>"}, {"location": "query/overview/", "title": "Query Engine \ud83d\udd0e", "text": "<p>The Query Engine is the retrieval module of the Graph RAG Library. It is one of the two main components of the Graph RAG library, the other being the Indexing Pipeline (see Indexing Pipeline). It is responsible for the following tasks:</p> <ul> <li>Local Search</li> <li>Global Search</li> <li>DRIFT Search</li> <li>Question Generation</li> </ul>"}, {"location": "query/overview/#local-search", "title": "Local Search", "text": "<p>Local search method generates answers by combining relevant data from the AI-extracted knowledge-graph with text chunks of the raw documents. This method is suitable for questions that require an understanding of specific entities mentioned in the documents (e.g. What are the healing properties of chamomile?).</p> <p>For more details about how Local Search works please refer to the Local Search documentation.</p>"}, {"location": "query/overview/#global-search", "title": "Global Search", "text": "<p>Global search method generates answers by searching over all AI-generated community reports in a map-reduce fashion. This is a resource-intensive method, but often gives good responses for questions that require an understanding of the dataset as a whole (e.g. What are the most significant values of the herbs mentioned in this notebook?).</p> <p>More about this can be checked at the Global Search documentation.</p>"}, {"location": "query/overview/#drift-search", "title": "DRIFT Search", "text": "<p>DRIFT Search introduces a new approach to local search queries by including community information in the search process. This greatly expands the breadth of the query\u2019s starting point and leads to retrieval and usage of a far higher variety of facts in the final answer. This addition expands the GraphRAG query engine by providing a more comprehensive option for local search, which uses community insights to refine a query into detailed follow-up questions.</p> <p>To learn more about DRIFT Search, please refer to the DRIFT Search documentation.</p>"}, {"location": "query/overview/#basic-search", "title": "Basic Search", "text": "<p>GraphRAG includes a rudimentary implementation of basic vector RAG to make it easy to compare different search results based on the type of question you are asking. You can specify the top <code>k</code> txt unit chunks to include in the summarization context.</p>"}, {"location": "query/overview/#question-generation", "title": "Question Generation", "text": "<p>This functionality takes a list of user queries and generates the next candidate questions. This is useful for generating follow-up questions in a conversation or for generating a list of questions for the investigator to dive deeper into the dataset.</p> <p>Information about how question generation works can be found at the Question Generation documentation page.</p>"}, {"location": "query/question_generation/", "title": "Question Generation \u2754", "text": ""}, {"location": "query/question_generation/#entity-based-question-generation", "title": "Entity-based Question Generation", "text": "<p>The question generation method combines structured data from the knowledge graph with unstructured data from the input documents to generate candidate questions related to specific entities.</p>"}, {"location": "query/question_generation/#methodology", "title": "Methodology", "text": "<p>Given a list of prior user questions, the question generation method uses the same context-building approach employed in local search to extract and prioritize relevant structured and unstructured data, including entities, relationships, covariates, community reports and raw text chunks. These data records are then fitted into a single LLM prompt to generate candidate follow-up questions that represent the most important or urgent information content or themes in the data.</p>"}, {"location": "query/question_generation/#configuration", "title": "Configuration", "text": "<p>Below are the key parameters of the Question Generation class:</p> <ul> <li><code>llm</code>: OpenAI model object to be used for response generation</li> <li><code>context_builder</code>: context builder object to be used for preparing context data from collections of knowledge model objects, using the same context builder class as in local search</li> <li><code>system_prompt</code>: prompt template used to generate candidate questions. Default template can be found at system_prompt</li> <li><code>llm_params</code>: a dictionary of additional parameters (e.g., temperature, max_tokens) to be passed to the LLM call</li> <li><code>context_builder_params</code>: a dictionary of additional parameters to be passed to the <code>context_builder</code> object when building context for the question generation prompt</li> <li><code>callbacks</code>: optional callback functions, can be used to provide custom event handlers for LLM's completion streaming events</li> </ul>"}, {"location": "query/question_generation/#how-to-use", "title": "How to Use", "text": "<p>An example of the question generation function can be found in the following notebook.</p>"}, {"location": "query/notebooks/overview/", "title": "API Notebooks", "text": "<ul> <li>API Overview Notebook</li> <li>Bring-Your-Own Vector Store</li> </ul>"}, {"location": "query/notebooks/overview/#query-engine-notebooks", "title": "Query Engine Notebooks", "text": "<p>For examples about running Query please refer to the following notebooks:</p> <ul> <li>Global Search Notebook</li> <li>Local Search Notebook</li> <li>DRIFT Search Notebook</li> </ul> <p>The test dataset for these notebooks can be found in dataset.zip.</p>"}]}